{"version":3,"file":"static/chunks/4347-1e623ad2cf55349a.js","mappings":"8IAGA,gBACA,MAAkB,eAAmB,IACrC,MACA,aAAY,QAAuB,EACnC,EAAkB,SAAa,yBAC/B,MAA2B,SAAG,mBAAqB,aAAiB,CACpE,SACA,2BAOA,GANA,YACA,MAAoB,YAAgB,IACpC,cACA,sBACA,kBAAyB,EAAa,2BAA2B,EAAkB,IACnF,EAEA,CACA,mBACA,SAqBA,OACA,eACa,eAAmB,KAEhC,mBACA,gBACA,OAAa,SAAa,CAC1B,MAAiB,WAAW,EAAU,IAAM,aAAmC,CAC/E,MAEA,CACA,EAEA,OADA,cACA,CAjCA,cACA,MAAwB,eAAmB,IAC3C,WACA,WACA,UACA,UAAc,mBAA8B,EAC5C,iBACA,EAAoB,SAAa,yBACjC,MAA6B,SAAG,mBAAqB,aAAiB,CACtE,SACA,2BAQA,GAPA,cACA,qBACA,EAAsB,YAAgB,IACtC,cACA,sBACA,kBAA2B,EAAa,2BAA2B,EAAkB,IACrF,EAEA,EAcA,SAEA,MACA,WACA,yBACA,WACA,iBACA,aACA,sBACA,CAAK,EACL,mBACA,4BAA2D,cAAqB,IAEhF,MADA,IACA,WAAkD,EAAU,GAC5D,OAAiB,UACjB,CAAO,GAAI,EACX,OAAa,SAAa,OAAU,WAAW,YAAoB,MAAgB,KACnF,CACA,EAEA,OADA,wBACA,CACA,EArBA,4CCrDA,yCAAuE,MAAkC,EAAI,EAC7G,mBAEA,GADA,OACA,4BACA,aAEA,CACA,6FCgBA,EAnBA,CACA,IACA,SACA,MACA,OACA,KACA,KACA,MACA,QACA,QACA,KACA,MACA,KACA,IACA,SACA,OACA,MACA,KACA,CACA,eACA,MAAe,QAAU,cAAc,EAAK,GAC5C,EAAe,YAAgB,SAC/B,YAAY,QAA6B,EAKzC,MAHA,4BACA,oCAE2B,SAAG,CAJ9B,MAI8B,CAAS,WAAsC,CAC7E,CAAG,EAEH,OADA,2BAAkC,EAAK,EACvC,CAAW,WACX,CAAC,GAAI,EACL,gBACA,GAAc,WAAkB,wBAChC,gECpCA,EAAyB,iBAAK,EAAL,sBAAK,oBAA8C,GAAe,CAC3F,YACA,OACA,cACA,gBACA,CAAG,CACH,SACC,EACD,oBAmCA,CACA,cACA,WACC,EACD,SAA4B,UAAc,IAC1C,EAAuB,QAAY,IACnC,EAAsB,QAAY,IAUlC,OATA,OACA,WACA,CAAG,MACD,WAAe,MACjB,gBACA,eACA,YAEA,CAAG,QACH,OACA,EApDA,CACA,cACA,UACA,CAAG,EACH,aACA,OACU,EACV,MAA4B,QAAY,aACpC,WAAe,MACnB,gBACA,UAEA,oCACA,aACA,GAAa,GAAQ,mBAAmB,EAHxC,4BAGwC,CAAM,KAAK,EAAG,4KAEtD,CACA,WACA,CAAK,OACL,CAcA,SAbmB,aAAiB,CACpC,IACA,MACA,kBA+BA,OA/BA,SACA,OACA,cAEA,EAAQ,IACR,IAEA,CAAK,CACL,WAEA,CA2BA,2GClEA,cACA,MAwBA,YACA,MAAoB,YAAgB,SACpC,aAAY,QAAyB,EACrC,GAAQ,gBAAoB,SAmD5B,MACA,EACA,EApDA,OAkDA,EAlDA,EAqDA,CADA,GADA,wDACA,wCAEA,MAGA,IADA,kDACA,wCAEA,YAEA,oBA5DA,WAyBA,KACA,OAA0B,MAC1B,gBACA,WACA,OACA,mBAEA,KACA,cACA,cAEA,OADA,QACA,CACA,EACQ,GACR,SAEM,YACN,MAAkC,WAC5B,iBACN,sCAEA,CACA,OAAW,UACX,EAhDA,WAIA,OAHA,SAA4B,UAAc,EAC1C,SAAoC,OAAW,SAElC,cAAkB,KAC/B,CACA,OAAW,UAAc,YAAuB,UAAc,gBAC9D,CAAG,EAEH,OADA,iBAA6B,EAAU,YACvC,CACA,EAvCA,GACA,EAAgB,YAAgB,SAChC,aAAY,QAAyB,EACrC,EAA0B,UAAc,YACxC,YACA,MACA,uBACA,WACA,MAIA,EAHA,EAAc,QAAc,YAA+B,UAAc,YACxD,gBAAoB,2BAKrC,MAA6B,SAAG,IAAc,oBAA2C,gBAAoB,IAAe,cAAkB,kBAA0C,CACxL,CACA,MAA2B,SAAG,IAAc,sBAA2C,CACvF,CAAG,EAEH,OADA,iBAAyB,EAAU,OACnC,CACA,CACA,gBAkBA,4BAWA,cACA,OAAS,gBAAoB,0EAC7B,mDCzDA,uBAA8C,iBAAqB,MACnE,mDCDA,cACA,MAAsB,QAAY,IAIlC,OAHE,WAAe,MACjB,WACA,CAAG,EACM,SAAa,kCACtB,8FCYM,EAAe,aAAuC,CAAC,EAAO,WAInB,EAH/C,GAAM,CAAE,UAAW,EAAe,GAAG,EAAY,CAAI,EAC/C,CAAC,EAAS,EAAU,CAAU,CADa,CACb,KAAV,GAAU,EAAS,GAC7C,EADkD,CAClD,IAAe,CAAC,IAAM,GAAW,GAAO,CAAH,CAAK,EAC1C,IAAM,EAAY,GAAkB,yDAAuB,+BAAU,MACrE,OAAO,EACH,cAAS,CAAa,UAAC,IAAS,CAAC,IAAV,CAAe,GAAG,EAAa,IAAK,EAAc,EAAI,GAC7E,IACN,CAAC,CAF2F,CAI5F,EAAO,YArBa,EAqBC,gEC5BrB,gBACA,wBACA,kBACI,GACJ,aAEA,CACA,iBACA,WACA,SACA,YACA,aAIA,OAHA,yBACA,OAEA,CACA,CAAK,EACL,KACA,WACA,YAAwB,WAAqB,KAC7C,WACA,qBACA,IAEA,YAEA,CACA,CAEA,CACA,CACA,iBACA,OAAS,aAAiB,WAC1B,2DEnBI,mEAJE,EAAiB,0BAMjB,EAAgC,gBAAc,CAClD,OAAQ,IAAI,IAA6B,uCACD,IAAI,IAA6B,SAC/D,IAAI,GAChB,CADmD,EAuC7C,EAAyB,aAC7B,CAAC,EAAO,SAYuC,EAAvB,EAXtB,GAAM,6BACJ,GAA8B,kBAC9B,uBACA,EACA,mCACA,YACA,EACA,GAAG,EACL,CAAI,EACE,EAAgB,aAAW,GAC3B,CAAC,EAAM,EAAO,CAAU,IAAV,MAAU,CAAyC,GADf,CACmB,EACrE,EAAsB,OAAtB,oBAAsB,wEAA6B,SACnD,CAAC,CAAE,EAAK,CAAU,EAAV,QAAU,CAAS,CAAC,CAAC,EAC7B,EAAe,OAAe,CAAC,EAAc,GAAU,EAAQA,IAC/D,CADmE,CAAC,MACrD,KAAK,EAAQ,MAAM,EAClC,CAAC,EAA4C,CAAI,CAAC,GAAG,EAAQ,mCAAhB,GAAsD,EAAE,MAAM,EAAE,EAC7G,EAAoD,EAAO,QAAQ,GACnE,EAAQ,EAAO,EAAO,QAAQ,GAAQ,CAAJ,EAClC,EAA8B,EAAQ,iBAF0E,qBAE1E,CAAuC,KAAO,EACpF,EAAyB,GAAS,EAElC,EAAqB,SAyItB,CACP,cACA,gGAA0B,EAAY,SAEhC,EAA2B,OAAc,CAAC,GAC1C,EAAoC,UAAO,GAC3C,EADgD,EACzB,OAAO,KAAO,CAAD,EAiE1C,OA/DM,YAAU,KACd,IAAM,EAAoB,IACxB,GAAI,EAAM,QAAU,CAAC,EAA4B,QAAS,CAGxD,IAASC,EAAT,WAAoD,EA5N/B,2BA8NjB,WACA,EACA,EACA,CAAE,UAAU,CAAK,EAErB,EATM,EAAc,CAAE,cAAe,CAAM,CAuBvC,CAAsB,SAAS,GAAzB,aACR,EAAc,oBAAoB,QAAS,EAAe,OAAO,EACjE,EAAe,QAAUA,EACzB,EAAc,iBAAiB,QAAS,EAAe,QAAS,CAAE,MAAM,CAAK,CAAC,GAE9EA,GAEJ,MAGE,CAHK,CAGS,oBAAoB,QAAS,EAAe,CALf,MAKsB,EAEnE,EAA4B,SAAU,CACxC,EAcM,EAAU,OAAO,WAAW,KAChC,EAAc,iBAAiB,cAAe,EAChD,EAAG,CAAC,EACJ,MAAO,IAF0D,CAG/D,OAAO,aAAa,GACpB,EAAc,EADa,iBACb,CAAoB,cAAe,GACjD,EAAc,YADoD,OACpD,CAAoB,QAAS,EAAe,OAAO,CACnE,CACF,EAAG,CAAC,EAAe,EAAyB,EAErC,CAEL,mBAJyC,EAInB,IAAO,EAA4B,QAAU,EACrE,CACF,EApNqD,IAC/C,IAAM,EAAS,EAAM,OACf,EAAwB,CAAC,GAAG,EAAQ,QAAQ,EAAE,KAAK,GAAY,EAAO,SAAS,KAChF,CADsF,CAAC,CAC7D,UAC/B,KAAuB,KAAK,EAD0B,EAEtD,KAAoB,GACf,EADoB,gBACd,CAAkB,cAC/B,EAAG,GAEG,EAAe,QAHU,CAqNjC,eACA,gGAA0B,EAAY,SAEhC,EAAqB,OAAc,CAAC,GACpC,EAAkC,SADgB,CACT,GAe/C,EAfoD,KAE9C,YAAU,KACd,IAAM,EAAc,IACd,EAAM,QAAU,CAAC,EAA0B,SAAS,EAxSxC,2BA0Se,KAAe,EADxB,CAAE,cAAe,CAAM,EACqB,CAC9D,UAAU,CACZ,CAAC,CAEL,EAEA,OADA,EAAc,iBAAiB,UAAW,GACnC,IAAM,EAAc,EAD0B,iBAC1B,CAAoB,UAAW,EAC5D,EAAG,CAAC,EAAe,EAAmB,EADiC,CAIrE,aAHmC,EAGnB,IAAO,EAA0B,SAAU,EAC3D,cAAe,IAAO,EAA0B,SAAU,CAC5D,CACF,EAzOyC,IACnC,IAAM,EAAS,EAAM,OACG,CAAC,GAAG,EAAQ,QAAQ,EAAE,KAAK,GAAY,EAAO,SAAS,MAAM,CAAC,KAEtF,KAAiB,KAAK,IACtB,KAAoB,GACf,EAAM,iBAAkB,cAC/B,EAAG,GAsDH,GAvD2C,IAG3C,GAFgB,MDhGpB,OCkGoB,SDlGpB,UACA,MAA0B,OAAc,IACtC,WAAe,MACjB,UACA,kBACA,IAEA,EAEA,OADA,gCAA+D,WAAe,EAC9E,uCAA+E,WAAe,CAC9F,CAAG,OACH,ECuFqB,IACQ,IAAU,EAAQ,OAAO,KAAO,UAEvD,KAAkB,GACd,CAAC,CADkB,CACZ,kBAAoB,IAC7B,EAAM,KADkC,SAClC,CAAe,EACrB,KAEJ,EAAG,GAFW,EAIR,QAFU,CAEV,CAAU,KACd,GAAK,CAAD,CAUJ,GAVW,IACP,IAC0D,GAAG,CAA3D,EAAQ,mBADmB,mBACnB,CAAuC,OACjD,EAA4B,EAAc,KAAK,MAAM,cACrD,EAAc,KAAK,MAAM,cAAgB,QAE3C,EAAQ,uCAAuC,IAAI,IAAI,EAEjD,OAAO,IAAI,GACnB,CADuB,GAEhB,KAEH,GACwD,GAJ7C,CAIX,EAAQ,uCAAuC,OAE/C,EAAc,KAAK,MAAM,cAAgB,EAE7C,CACF,EAAG,CAAC,EAAM,EAAe,EAA6B,EAAQ,EAQxD,GARuD,QAQvD,CAAU,IACP,KACA,IACL,CADW,CACH,OAAO,OAAO,GACtB,CAD0B,CAClB,uCAAuC,OAAO,GACtD,CAD0D,GAE5D,EACC,CAAC,EAAM,EAAQ,EAEZ,EAJa,CAEF,QAEX,CAAU,KACd,IAAM,EAAe,IAAM,EAAM,CAAC,CAAC,EAEnC,OADA,SAAS,iBAAiB,EAAgB,GACnC,IAAM,KADyC,IAChC,oBAAoB,EAAgB,EAC5D,EAAG,CAAC,CAAC,EAGH,IAJsE,CAItE,KAAC,IAAS,CAAC,IAAV,CACE,GAAG,EACJ,IAAK,EACL,MAAO,CACL,cAAe,EACX,EACE,OACA,OACF,OACJ,GAAG,EAAM,OAEX,eAAgB,OAAoB,CAAC,EAAM,eAAgB,EAAa,cAAc,EACtF,cAAe,OAAoB,CAAC,EAAM,cAAe,EAAa,aAAa,EACnF,qBAAsB,OAAoB,CACxC,EAAM,qBACN,EAAmB,qBACrB,EAGN,GAGF,EAAiB,YArKc,EAqKA,iBAW/B,IAAM,EAA+B,aAGnC,CAAC,EAAO,KACR,IAAM,EAAgB,aAAW,GAC3B,EAAY,SAAsC,IAAI,EACtD,EAAe,CAFmC,EAEnC,IAAe,CAAC,EAAc,GAYnD,OAAO,EAVD,UAAU,KACd,IAAM,EAAO,EAAI,QACjB,GAAI,EAEF,IAFQ,GACR,EAAQ,SAAS,IAAI,GACd,CADkB,IAEvB,EAAQ,SAAS,OAAO,EAC1B,CAEJ,CAHkC,CAG/B,CAAC,EAAQ,QAAQ,CAAC,EAEd,UAAC,IAAS,CAAC,IAAV,CAAe,GAAG,EAAO,IAAK,EAAc,CACtD,CAAC,EAyHD,SAAS,IACP,IAAM,EAAQ,IAAI,GADM,SACM,GAC9B,SAAS,EADmC,WACnC,CAAc,EACzB,CAEA,EAH8B,OAGrB,EACP,EACA,EACA,GACW,EACX,aADE,EAAS,CAAX,EAEM,EAAS,EAAO,cAAc,OAC9B,EAAQ,IAAI,YAAY,EAAM,CAAE,SAAS,EAAO,YAAY,SAAM,CAAO,CAAC,EAC5E,GAAS,EAAO,GAAP,aAAO,CAAiB,EAAM,EAA0B,CAAE,MAAM,CAAK,CAAC,EAE/E,EACF,QADY,CACgB,EAAQ,GAEpC,EAFyC,aAElC,CAAc,EAEzB,CA3IA,EAAuB,YA1BH,EA0BiB,uBA6IrC,IAAM,EAAO,EACP,EAAS","sources":["webpack://_N_E/./node_modules/.pnpm/@radix-ui+react-context@1.1.2_@types+react@19.0.12_react@19.0.0/node_modules/@radix-ui/react-context/dist/index.mjs","webpack://_N_E/./node_modules/.pnpm/@radix-ui+primitive@1.1.2/node_modules/@radix-ui/primitive/dist/index.mjs","webpack://_N_E/./node_modules/.pnpm/@radix-ui+react-primitive@2.1.3_@types+react-dom@19.0.4_@types+react@19.0.12__@types+re_6ef724cac360d282b7e5e35bf17ac572/node_modules/@radix-ui/react-primitive/dist/index.mjs","webpack://_N_E/./node_modules/.pnpm/@radix-ui+react-use-controllable-state@1.2.2_@types+react@19.0.12_react@19.0.0/node_modules/@radix-ui/react-use-controllable-state/dist/index.mjs","webpack://_N_E/./node_modules/.pnpm/@radix-ui+react-slot@1.2.3_@types+react@19.0.12_react@19.0.0/node_modules/@radix-ui/react-slot/dist/index.mjs","webpack://_N_E/./node_modules/.pnpm/@radix-ui+react-use-layout-effect@1.1.1_@types+react@19.0.12_react@19.0.0/node_modules/@radix-ui/react-use-layout-effect/dist/index.mjs","webpack://_N_E/./node_modules/.pnpm/@radix-ui+react-use-callback-ref@1.1.1_@types+react@19.0.12_react@19.0.0/node_modules/@radix-ui/react-use-callback-ref/dist/index.mjs","webpack://_N_E/../src/portal.tsx","webpack://_N_E/./node_modules/.pnpm/@radix-ui+react-compose-refs@1.1.2_@types+react@19.0.12_react@19.0.0/node_modules/@radix-ui/react-compose-refs/dist/index.mjs","webpack://_N_E/./node_modules/.pnpm/@radix-ui+react-use-escape-keydown@1.1.1_@types+react@19.0.12_react@19.0.0/node_modules/@radix-ui/react-use-escape-keydown/dist/index.mjs","webpack://_N_E/../src/dismissable-layer.tsx"],"sourcesContent":["// packages/react/context/src/create-context.tsx\nimport * as React from \"react\";\nimport { jsx } from \"react/jsx-runtime\";\nfunction createContext2(rootComponentName, defaultContext) {\n  const Context = React.createContext(defaultContext);\n  const Provider = (props) => {\n    const { children, ...context } = props;\n    const value = React.useMemo(() => context, Object.values(context));\n    return /* @__PURE__ */ jsx(Context.Provider, { value, children });\n  };\n  Provider.displayName = rootComponentName + \"Provider\";\n  function useContext2(consumerName) {\n    const context = React.useContext(Context);\n    if (context) return context;\n    if (defaultContext !== void 0) return defaultContext;\n    throw new Error(`\\`${consumerName}\\` must be used within \\`${rootComponentName}\\``);\n  }\n  return [Provider, useContext2];\n}\nfunction createContextScope(scopeName, createContextScopeDeps = []) {\n  let defaultContexts = [];\n  function createContext3(rootComponentName, defaultContext) {\n    const BaseContext = React.createContext(defaultContext);\n    const index = defaultContexts.length;\n    defaultContexts = [...defaultContexts, defaultContext];\n    const Provider = (props) => {\n      const { scope, children, ...context } = props;\n      const Context = scope?.[scopeName]?.[index] || BaseContext;\n      const value = React.useMemo(() => context, Object.values(context));\n      return /* @__PURE__ */ jsx(Context.Provider, { value, children });\n    };\n    Provider.displayName = rootComponentName + \"Provider\";\n    function useContext2(consumerName, scope) {\n      const Context = scope?.[scopeName]?.[index] || BaseContext;\n      const context = React.useContext(Context);\n      if (context) return context;\n      if (defaultContext !== void 0) return defaultContext;\n      throw new Error(`\\`${consumerName}\\` must be used within \\`${rootComponentName}\\``);\n    }\n    return [Provider, useContext2];\n  }\n  const createScope = () => {\n    const scopeContexts = defaultContexts.map((defaultContext) => {\n      return React.createContext(defaultContext);\n    });\n    return function useScope(scope) {\n      const contexts = scope?.[scopeName] || scopeContexts;\n      return React.useMemo(\n        () => ({ [`__scope${scopeName}`]: { ...scope, [scopeName]: contexts } }),\n        [scope, contexts]\n      );\n    };\n  };\n  createScope.scopeName = scopeName;\n  return [createContext3, composeContextScopes(createScope, ...createContextScopeDeps)];\n}\nfunction composeContextScopes(...scopes) {\n  const baseScope = scopes[0];\n  if (scopes.length === 1) return baseScope;\n  const createScope = () => {\n    const scopeHooks = scopes.map((createScope2) => ({\n      useScope: createScope2(),\n      scopeName: createScope2.scopeName\n    }));\n    return function useComposedScopes(overrideScopes) {\n      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {\n        const scopeProps = useScope(overrideScopes);\n        const currentScope = scopeProps[`__scope${scopeName}`];\n        return { ...nextScopes2, ...currentScope };\n      }, {});\n      return React.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);\n    };\n  };\n  createScope.scopeName = baseScope.scopeName;\n  return createScope;\n}\nexport {\n  createContext2 as createContext,\n  createContextScope\n};\n//# sourceMappingURL=index.mjs.map\n","// packages/core/primitive/src/primitive.tsx\nfunction composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {\n  return function handleEvent(event) {\n    originalEventHandler?.(event);\n    if (checkForDefaultPrevented === false || !event.defaultPrevented) {\n      return ourEventHandler?.(event);\n    }\n  };\n}\nexport {\n  composeEventHandlers\n};\n//# sourceMappingURL=index.mjs.map\n","// src/primitive.tsx\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { createSlot } from \"@radix-ui/react-slot\";\nimport { jsx } from \"react/jsx-runtime\";\nvar NODES = [\n  \"a\",\n  \"button\",\n  \"div\",\n  \"form\",\n  \"h2\",\n  \"h3\",\n  \"img\",\n  \"input\",\n  \"label\",\n  \"li\",\n  \"nav\",\n  \"ol\",\n  \"p\",\n  \"select\",\n  \"span\",\n  \"svg\",\n  \"ul\"\n];\nvar Primitive = NODES.reduce((primitive, node) => {\n  const Slot = createSlot(`Primitive.${node}`);\n  const Node = React.forwardRef((props, forwardedRef) => {\n    const { asChild, ...primitiveProps } = props;\n    const Comp = asChild ? Slot : node;\n    if (typeof window !== \"undefined\") {\n      window[Symbol.for(\"radix-ui\")] = true;\n    }\n    return /* @__PURE__ */ jsx(Comp, { ...primitiveProps, ref: forwardedRef });\n  });\n  Node.displayName = `Primitive.${node}`;\n  return { ...primitive, [node]: Node };\n}, {});\nfunction dispatchDiscreteCustomEvent(target, event) {\n  if (target) ReactDOM.flushSync(() => target.dispatchEvent(event));\n}\nvar Root = Primitive;\nexport {\n  Primitive,\n  Root,\n  dispatchDiscreteCustomEvent\n};\n//# sourceMappingURL=index.mjs.map\n","// src/use-controllable-state.tsx\nimport * as React from \"react\";\nimport { useLayoutEffect } from \"@radix-ui/react-use-layout-effect\";\nvar useInsertionEffect = React[\" useInsertionEffect \".trim().toString()] || useLayoutEffect;\nfunction useControllableState({\n  prop,\n  defaultProp,\n  onChange = () => {\n  },\n  caller\n}) {\n  const [uncontrolledProp, setUncontrolledProp, onChangeRef] = useUncontrolledState({\n    defaultProp,\n    onChange\n  });\n  const isControlled = prop !== void 0;\n  const value = isControlled ? prop : uncontrolledProp;\n  if (true) {\n    const isControlledRef = React.useRef(prop !== void 0);\n    React.useEffect(() => {\n      const wasControlled = isControlledRef.current;\n      if (wasControlled !== isControlled) {\n        const from = wasControlled ? \"controlled\" : \"uncontrolled\";\n        const to = isControlled ? \"controlled\" : \"uncontrolled\";\n        console.warn(\n          `${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`\n        );\n      }\n      isControlledRef.current = isControlled;\n    }, [isControlled, caller]);\n  }\n  const setValue = React.useCallback(\n    (nextValue) => {\n      if (isControlled) {\n        const value2 = isFunction(nextValue) ? nextValue(prop) : nextValue;\n        if (value2 !== prop) {\n          onChangeRef.current?.(value2);\n        }\n      } else {\n        setUncontrolledProp(nextValue);\n      }\n    },\n    [isControlled, prop, setUncontrolledProp, onChangeRef]\n  );\n  return [value, setValue];\n}\nfunction useUncontrolledState({\n  defaultProp,\n  onChange\n}) {\n  const [value, setValue] = React.useState(defaultProp);\n  const prevValueRef = React.useRef(value);\n  const onChangeRef = React.useRef(onChange);\n  useInsertionEffect(() => {\n    onChangeRef.current = onChange;\n  }, [onChange]);\n  React.useEffect(() => {\n    if (prevValueRef.current !== value) {\n      onChangeRef.current?.(value);\n      prevValueRef.current = value;\n    }\n  }, [value, prevValueRef]);\n  return [value, setValue, onChangeRef];\n}\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\n\n// src/use-controllable-state-reducer.tsx\nimport * as React2 from \"react\";\nimport { useEffectEvent } from \"@radix-ui/react-use-effect-event\";\nvar SYNC_STATE = Symbol(\"RADIX:SYNC_STATE\");\nfunction useControllableStateReducer(reducer, userArgs, initialArg, init) {\n  const { prop: controlledState, defaultProp, onChange: onChangeProp, caller } = userArgs;\n  const isControlled = controlledState !== void 0;\n  const onChange = useEffectEvent(onChangeProp);\n  if (true) {\n    const isControlledRef = React2.useRef(controlledState !== void 0);\n    React2.useEffect(() => {\n      const wasControlled = isControlledRef.current;\n      if (wasControlled !== isControlled) {\n        const from = wasControlled ? \"controlled\" : \"uncontrolled\";\n        const to = isControlled ? \"controlled\" : \"uncontrolled\";\n        console.warn(\n          `${caller} is changing from ${from} to ${to}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`\n        );\n      }\n      isControlledRef.current = isControlled;\n    }, [isControlled, caller]);\n  }\n  const args = [{ ...initialArg, state: defaultProp }];\n  if (init) {\n    args.push(init);\n  }\n  const [internalState, dispatch] = React2.useReducer(\n    (state2, action) => {\n      if (action.type === SYNC_STATE) {\n        return { ...state2, state: action.state };\n      }\n      const next = reducer(state2, action);\n      if (isControlled && !Object.is(next.state, state2.state)) {\n        onChange(next.state);\n      }\n      return next;\n    },\n    ...args\n  );\n  const uncontrolledState = internalState.state;\n  const prevValueRef = React2.useRef(uncontrolledState);\n  React2.useEffect(() => {\n    if (prevValueRef.current !== uncontrolledState) {\n      prevValueRef.current = uncontrolledState;\n      if (!isControlled) {\n        onChange(uncontrolledState);\n      }\n    }\n  }, [onChange, uncontrolledState, prevValueRef, isControlled]);\n  const state = React2.useMemo(() => {\n    const isControlled2 = controlledState !== void 0;\n    if (isControlled2) {\n      return { ...internalState, state: controlledState };\n    }\n    return internalState;\n  }, [internalState, controlledState]);\n  React2.useEffect(() => {\n    if (isControlled && !Object.is(controlledState, internalState.state)) {\n      dispatch({ type: SYNC_STATE, state: controlledState });\n    }\n  }, [controlledState, internalState.state, isControlled]);\n  return [state, dispatch];\n}\nexport {\n  useControllableState,\n  useControllableStateReducer\n};\n//# sourceMappingURL=index.mjs.map\n","// src/slot.tsx\nimport * as React from \"react\";\nimport { composeRefs } from \"@radix-ui/react-compose-refs\";\nimport { Fragment as Fragment2, jsx } from \"react/jsx-runtime\";\n// @__NO_SIDE_EFFECTS__\nfunction createSlot(ownerName) {\n  const SlotClone = /* @__PURE__ */ createSlotClone(ownerName);\n  const Slot2 = React.forwardRef((props, forwardedRef) => {\n    const { children, ...slotProps } = props;\n    const childrenArray = React.Children.toArray(children);\n    const slottable = childrenArray.find(isSlottable);\n    if (slottable) {\n      const newElement = slottable.props.children;\n      const newChildren = childrenArray.map((child) => {\n        if (child === slottable) {\n          if (React.Children.count(newElement) > 1) return React.Children.only(null);\n          return React.isValidElement(newElement) ? newElement.props.children : null;\n        } else {\n          return child;\n        }\n      });\n      return /* @__PURE__ */ jsx(SlotClone, { ...slotProps, ref: forwardedRef, children: React.isValidElement(newElement) ? React.cloneElement(newElement, void 0, newChildren) : null });\n    }\n    return /* @__PURE__ */ jsx(SlotClone, { ...slotProps, ref: forwardedRef, children });\n  });\n  Slot2.displayName = `${ownerName}.Slot`;\n  return Slot2;\n}\nvar Slot = /* @__PURE__ */ createSlot(\"Slot\");\n// @__NO_SIDE_EFFECTS__\nfunction createSlotClone(ownerName) {\n  const SlotClone = React.forwardRef((props, forwardedRef) => {\n    const { children, ...slotProps } = props;\n    if (React.isValidElement(children)) {\n      const childrenRef = getElementRef(children);\n      const props2 = mergeProps(slotProps, children.props);\n      if (children.type !== React.Fragment) {\n        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;\n      }\n      return React.cloneElement(children, props2);\n    }\n    return React.Children.count(children) > 1 ? React.Children.only(null) : null;\n  });\n  SlotClone.displayName = `${ownerName}.SlotClone`;\n  return SlotClone;\n}\nvar SLOTTABLE_IDENTIFIER = Symbol(\"radix.slottable\");\n// @__NO_SIDE_EFFECTS__\nfunction createSlottable(ownerName) {\n  const Slottable2 = ({ children }) => {\n    return /* @__PURE__ */ jsx(Fragment2, { children });\n  };\n  Slottable2.displayName = `${ownerName}.Slottable`;\n  Slottable2.__radixId = SLOTTABLE_IDENTIFIER;\n  return Slottable2;\n}\nvar Slottable = /* @__PURE__ */ createSlottable(\"Slottable\");\nfunction isSlottable(child) {\n  return React.isValidElement(child) && typeof child.type === \"function\" && \"__radixId\" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;\n}\nfunction mergeProps(slotProps, childProps) {\n  const overrideProps = { ...childProps };\n  for (const propName in childProps) {\n    const slotPropValue = slotProps[propName];\n    const childPropValue = childProps[propName];\n    const isHandler = /^on[A-Z]/.test(propName);\n    if (isHandler) {\n      if (slotPropValue && childPropValue) {\n        overrideProps[propName] = (...args) => {\n          const result = childPropValue(...args);\n          slotPropValue(...args);\n          return result;\n        };\n      } else if (slotPropValue) {\n        overrideProps[propName] = slotPropValue;\n      }\n    } else if (propName === \"style\") {\n      overrideProps[propName] = { ...slotPropValue, ...childPropValue };\n    } else if (propName === \"className\") {\n      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(\" \");\n    }\n  }\n  return { ...slotProps, ...overrideProps };\n}\nfunction getElementRef(element) {\n  let getter = Object.getOwnPropertyDescriptor(element.props, \"ref\")?.get;\n  let mayWarn = getter && \"isReactWarning\" in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return element.ref;\n  }\n  getter = Object.getOwnPropertyDescriptor(element, \"ref\")?.get;\n  mayWarn = getter && \"isReactWarning\" in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return element.props.ref;\n  }\n  return element.props.ref || element.ref;\n}\nexport {\n  Slot as Root,\n  Slot,\n  Slottable,\n  createSlot,\n  createSlottable\n};\n//# sourceMappingURL=index.mjs.map\n","// packages/react/use-layout-effect/src/use-layout-effect.tsx\nimport * as React from \"react\";\nvar useLayoutEffect2 = globalThis?.document ? React.useLayoutEffect : () => {\n};\nexport {\n  useLayoutEffect2 as useLayoutEffect\n};\n//# sourceMappingURL=index.mjs.map\n","// packages/react/use-callback-ref/src/use-callback-ref.tsx\nimport * as React from \"react\";\nfunction useCallbackRef(callback) {\n  const callbackRef = React.useRef(callback);\n  React.useEffect(() => {\n    callbackRef.current = callback;\n  });\n  return React.useMemo(() => (...args) => callbackRef.current?.(...args), []);\n}\nexport {\n  useCallbackRef\n};\n//# sourceMappingURL=index.mjs.map\n","import * as React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\n\n/* -------------------------------------------------------------------------------------------------\n * Portal\n * -----------------------------------------------------------------------------------------------*/\n\nconst PORTAL_NAME = 'Portal';\n\ntype PortalElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface PortalProps extends PrimitiveDivProps {\n  /**\n   * An optional container where the portaled content should be appended.\n   */\n  container?: Element | DocumentFragment | null;\n}\n\nconst Portal = React.forwardRef<PortalElement, PortalProps>((props, forwardedRef) => {\n  const { container: containerProp, ...portalProps } = props;\n  const [mounted, setMounted] = React.useState(false);\n  useLayoutEffect(() => setMounted(true), []);\n  const container = containerProp || (mounted && globalThis?.document?.body);\n  return container\n    ? ReactDOM.createPortal(<Primitive.div {...portalProps} ref={forwardedRef} />, container)\n    : null;\n});\n\nPortal.displayName = PORTAL_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst Root = Portal;\n\nexport {\n  Portal,\n  //\n  Root,\n};\nexport type { PortalProps };\n","// packages/react/compose-refs/src/compose-refs.tsx\nimport * as React from \"react\";\nfunction setRef(ref, value) {\n  if (typeof ref === \"function\") {\n    return ref(value);\n  } else if (ref !== null && ref !== void 0) {\n    ref.current = value;\n  }\n}\nfunction composeRefs(...refs) {\n  return (node) => {\n    let hasCleanup = false;\n    const cleanups = refs.map((ref) => {\n      const cleanup = setRef(ref, node);\n      if (!hasCleanup && typeof cleanup == \"function\") {\n        hasCleanup = true;\n      }\n      return cleanup;\n    });\n    if (hasCleanup) {\n      return () => {\n        for (let i = 0; i < cleanups.length; i++) {\n          const cleanup = cleanups[i];\n          if (typeof cleanup == \"function\") {\n            cleanup();\n          } else {\n            setRef(refs[i], null);\n          }\n        }\n      };\n    }\n  };\n}\nfunction useComposedRefs(...refs) {\n  return React.useCallback(composeRefs(...refs), refs);\n}\nexport {\n  composeRefs,\n  useComposedRefs\n};\n//# sourceMappingURL=index.mjs.map\n","// packages/react/use-escape-keydown/src/use-escape-keydown.tsx\nimport * as React from \"react\";\nimport { useCallbackRef } from \"@radix-ui/react-use-callback-ref\";\nfunction useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis?.document) {\n  const onEscapeKeyDown = useCallbackRef(onEscapeKeyDownProp);\n  React.useEffect(() => {\n    const handleKeyDown = (event) => {\n      if (event.key === \"Escape\") {\n        onEscapeKeyDown(event);\n      }\n    };\n    ownerDocument.addEventListener(\"keydown\", handleKeyDown, { capture: true });\n    return () => ownerDocument.removeEventListener(\"keydown\", handleKeyDown, { capture: true });\n  }, [onEscapeKeyDown, ownerDocument]);\n}\nexport {\n  useEscapeKeydown\n};\n//# sourceMappingURL=index.mjs.map\n","import * as React from 'react';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { Primitive, dispatchDiscreteCustomEvent } from '@radix-ui/react-primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useEscapeKeydown } from '@radix-ui/react-use-escape-keydown';\n\n/* -------------------------------------------------------------------------------------------------\n * DismissableLayer\n * -----------------------------------------------------------------------------------------------*/\n\nconst DISMISSABLE_LAYER_NAME = 'DismissableLayer';\nconst CONTEXT_UPDATE = 'dismissableLayer.update';\nconst POINTER_DOWN_OUTSIDE = 'dismissableLayer.pointerDownOutside';\nconst FOCUS_OUTSIDE = 'dismissableLayer.focusOutside';\n\nlet originalBodyPointerEvents: string;\n\nconst DismissableLayerContext = React.createContext({\n  layers: new Set<DismissableLayerElement>(),\n  layersWithOutsidePointerEventsDisabled: new Set<DismissableLayerElement>(),\n  branches: new Set<DismissableLayerBranchElement>(),\n});\n\ntype DismissableLayerElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface DismissableLayerProps extends PrimitiveDivProps {\n  /**\n   * When `true`, hover/focus/click interactions will be disabled on elements outside\n   * the `DismissableLayer`. Users will need to click twice on outside elements to\n   * interact with them: once to close the `DismissableLayer`, and again to trigger the element.\n   */\n  disableOutsidePointerEvents?: boolean;\n  /**\n   * Event handler called when the escape key is down.\n   * Can be prevented.\n   */\n  onEscapeKeyDown?: (event: KeyboardEvent) => void;\n  /**\n   * Event handler called when the a `pointerdown` event happens outside of the `DismissableLayer`.\n   * Can be prevented.\n   */\n  onPointerDownOutside?: (event: PointerDownOutsideEvent) => void;\n  /**\n   * Event handler called when the focus moves outside of the `DismissableLayer`.\n   * Can be prevented.\n   */\n  onFocusOutside?: (event: FocusOutsideEvent) => void;\n  /**\n   * Event handler called when an interaction happens outside the `DismissableLayer`.\n   * Specifically, when a `pointerdown` event happens outside or focus moves outside of it.\n   * Can be prevented.\n   */\n  onInteractOutside?: (event: PointerDownOutsideEvent | FocusOutsideEvent) => void;\n  /**\n   * Handler called when the `DismissableLayer` should be dismissed\n   */\n  onDismiss?: () => void;\n}\n\nconst DismissableLayer = React.forwardRef<DismissableLayerElement, DismissableLayerProps>(\n  (props, forwardedRef) => {\n    const {\n      disableOutsidePointerEvents = false,\n      onEscapeKeyDown,\n      onPointerDownOutside,\n      onFocusOutside,\n      onInteractOutside,\n      onDismiss,\n      ...layerProps\n    } = props;\n    const context = React.useContext(DismissableLayerContext);\n    const [node, setNode] = React.useState<DismissableLayerElement | null>(null);\n    const ownerDocument = node?.ownerDocument ?? globalThis?.document;\n    const [, force] = React.useState({});\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setNode(node));\n    const layers = Array.from(context.layers);\n    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1); // prettier-ignore\n    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled!); // prettier-ignore\n    const index = node ? layers.indexOf(node) : -1;\n    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;\n    const isPointerEventsEnabled = index >= highestLayerWithOutsidePointerEventsDisabledIndex;\n\n    const pointerDownOutside = usePointerDownOutside((event) => {\n      const target = event.target as HTMLElement;\n      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));\n      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;\n      onPointerDownOutside?.(event);\n      onInteractOutside?.(event);\n      if (!event.defaultPrevented) onDismiss?.();\n    }, ownerDocument);\n\n    const focusOutside = useFocusOutside((event) => {\n      const target = event.target as HTMLElement;\n      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));\n      if (isFocusInBranch) return;\n      onFocusOutside?.(event);\n      onInteractOutside?.(event);\n      if (!event.defaultPrevented) onDismiss?.();\n    }, ownerDocument);\n\n    useEscapeKeydown((event) => {\n      const isHighestLayer = index === context.layers.size - 1;\n      if (!isHighestLayer) return;\n      onEscapeKeyDown?.(event);\n      if (!event.defaultPrevented && onDismiss) {\n        event.preventDefault();\n        onDismiss();\n      }\n    }, ownerDocument);\n\n    React.useEffect(() => {\n      if (!node) return;\n      if (disableOutsidePointerEvents) {\n        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {\n          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;\n          ownerDocument.body.style.pointerEvents = 'none';\n        }\n        context.layersWithOutsidePointerEventsDisabled.add(node);\n      }\n      context.layers.add(node);\n      dispatchUpdate();\n      return () => {\n        if (\n          disableOutsidePointerEvents &&\n          context.layersWithOutsidePointerEventsDisabled.size === 1\n        ) {\n          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;\n        }\n      };\n    }, [node, ownerDocument, disableOutsidePointerEvents, context]);\n\n    /**\n     * We purposefully prevent combining this effect with the `disableOutsidePointerEvents` effect\n     * because a change to `disableOutsidePointerEvents` would remove this layer from the stack\n     * and add it to the end again so the layering order wouldn't be _creation order_.\n     * We only want them to be removed from context stacks when unmounted.\n     */\n    React.useEffect(() => {\n      return () => {\n        if (!node) return;\n        context.layers.delete(node);\n        context.layersWithOutsidePointerEventsDisabled.delete(node);\n        dispatchUpdate();\n      };\n    }, [node, context]);\n\n    React.useEffect(() => {\n      const handleUpdate = () => force({});\n      document.addEventListener(CONTEXT_UPDATE, handleUpdate);\n      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);\n    }, []);\n\n    return (\n      <Primitive.div\n        {...layerProps}\n        ref={composedRefs}\n        style={{\n          pointerEvents: isBodyPointerEventsDisabled\n            ? isPointerEventsEnabled\n              ? 'auto'\n              : 'none'\n            : undefined,\n          ...props.style,\n        }}\n        onFocusCapture={composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture)}\n        onBlurCapture={composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture)}\n        onPointerDownCapture={composeEventHandlers(\n          props.onPointerDownCapture,\n          pointerDownOutside.onPointerDownCapture\n        )}\n      />\n    );\n  }\n);\n\nDismissableLayer.displayName = DISMISSABLE_LAYER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * DismissableLayerBranch\n * -----------------------------------------------------------------------------------------------*/\n\nconst BRANCH_NAME = 'DismissableLayerBranch';\n\ntype DismissableLayerBranchElement = React.ComponentRef<typeof Primitive.div>;\ninterface DismissableLayerBranchProps extends PrimitiveDivProps {}\n\nconst DismissableLayerBranch = React.forwardRef<\n  DismissableLayerBranchElement,\n  DismissableLayerBranchProps\n>((props, forwardedRef) => {\n  const context = React.useContext(DismissableLayerContext);\n  const ref = React.useRef<DismissableLayerBranchElement>(null);\n  const composedRefs = useComposedRefs(forwardedRef, ref);\n\n  React.useEffect(() => {\n    const node = ref.current;\n    if (node) {\n      context.branches.add(node);\n      return () => {\n        context.branches.delete(node);\n      };\n    }\n  }, [context.branches]);\n\n  return <Primitive.div {...props} ref={composedRefs} />;\n});\n\nDismissableLayerBranch.displayName = BRANCH_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype PointerDownOutsideEvent = CustomEvent<{ originalEvent: PointerEvent }>;\ntype FocusOutsideEvent = CustomEvent<{ originalEvent: FocusEvent }>;\n\n/**\n * Listens for `pointerdown` outside a react subtree. We use `pointerdown` rather than `pointerup`\n * to mimic layer dismissing behaviour present in OS.\n * Returns props to pass to the node we want to check for outside events.\n */\nfunction usePointerDownOutside(\n  onPointerDownOutside?: (event: PointerDownOutsideEvent) => void,\n  ownerDocument: Document = globalThis?.document\n) {\n  const handlePointerDownOutside = useCallbackRef(onPointerDownOutside) as EventListener;\n  const isPointerInsideReactTreeRef = React.useRef(false);\n  const handleClickRef = React.useRef(() => {});\n\n  React.useEffect(() => {\n    const handlePointerDown = (event: PointerEvent) => {\n      if (event.target && !isPointerInsideReactTreeRef.current) {\n        const eventDetail = { originalEvent: event };\n\n        function handleAndDispatchPointerDownOutsideEvent() {\n          handleAndDispatchCustomEvent(\n            POINTER_DOWN_OUTSIDE,\n            handlePointerDownOutside,\n            eventDetail,\n            { discrete: true }\n          );\n        }\n\n        /**\n         * On touch devices, we need to wait for a click event because browsers implement\n         * a ~350ms delay between the time the user stops touching the display and when the\n         * browser executres events. We need to ensure we don't reactivate pointer-events within\n         * this timeframe otherwise the browser may execute events that should have been prevented.\n         *\n         * Additionally, this also lets us deal automatically with cancellations when a click event\n         * isn't raised because the page was considered scrolled/drag-scrolled, long-pressed, etc.\n         *\n         * This is why we also continuously remove the previous listener, because we cannot be\n         * certain that it was raised, and therefore cleaned-up.\n         */\n        if (event.pointerType === 'touch') {\n          ownerDocument.removeEventListener('click', handleClickRef.current);\n          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent;\n          ownerDocument.addEventListener('click', handleClickRef.current, { once: true });\n        } else {\n          handleAndDispatchPointerDownOutsideEvent();\n        }\n      } else {\n        // We need to remove the event listener in case the outside click has been canceled.\n        // See: https://github.com/radix-ui/primitives/issues/2171\n        ownerDocument.removeEventListener('click', handleClickRef.current);\n      }\n      isPointerInsideReactTreeRef.current = false;\n    };\n    /**\n     * if this hook executes in a component that mounts via a `pointerdown` event, the event\n     * would bubble up to the document and trigger a `pointerDownOutside` event. We avoid\n     * this by delaying the event listener registration on the document.\n     * This is not React specific, but rather how the DOM works, ie:\n     * ```\n     * button.addEventListener('pointerdown', () => {\n     *   console.log('I will log');\n     *   document.addEventListener('pointerdown', () => {\n     *     console.log('I will also log');\n     *   })\n     * });\n     */\n    const timerId = window.setTimeout(() => {\n      ownerDocument.addEventListener('pointerdown', handlePointerDown);\n    }, 0);\n    return () => {\n      window.clearTimeout(timerId);\n      ownerDocument.removeEventListener('pointerdown', handlePointerDown);\n      ownerDocument.removeEventListener('click', handleClickRef.current);\n    };\n  }, [ownerDocument, handlePointerDownOutside]);\n\n  return {\n    // ensures we check React component tree (not just DOM tree)\n    onPointerDownCapture: () => (isPointerInsideReactTreeRef.current = true),\n  };\n}\n\n/**\n * Listens for when focus happens outside a react subtree.\n * Returns props to pass to the root (node) of the subtree we want to check.\n */\nfunction useFocusOutside(\n  onFocusOutside?: (event: FocusOutsideEvent) => void,\n  ownerDocument: Document = globalThis?.document\n) {\n  const handleFocusOutside = useCallbackRef(onFocusOutside) as EventListener;\n  const isFocusInsideReactTreeRef = React.useRef(false);\n\n  React.useEffect(() => {\n    const handleFocus = (event: FocusEvent) => {\n      if (event.target && !isFocusInsideReactTreeRef.current) {\n        const eventDetail = { originalEvent: event };\n        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {\n          discrete: false,\n        });\n      }\n    };\n    ownerDocument.addEventListener('focusin', handleFocus);\n    return () => ownerDocument.removeEventListener('focusin', handleFocus);\n  }, [ownerDocument, handleFocusOutside]);\n\n  return {\n    onFocusCapture: () => (isFocusInsideReactTreeRef.current = true),\n    onBlurCapture: () => (isFocusInsideReactTreeRef.current = false),\n  };\n}\n\nfunction dispatchUpdate() {\n  const event = new CustomEvent(CONTEXT_UPDATE);\n  document.dispatchEvent(event);\n}\n\nfunction handleAndDispatchCustomEvent<E extends CustomEvent, OriginalEvent extends Event>(\n  name: string,\n  handler: ((event: E) => void) | undefined,\n  detail: { originalEvent: OriginalEvent } & (E extends CustomEvent<infer D> ? D : never),\n  { discrete }: { discrete: boolean }\n) {\n  const target = detail.originalEvent.target;\n  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });\n  if (handler) target.addEventListener(name, handler as EventListener, { once: true });\n\n  if (discrete) {\n    dispatchDiscreteCustomEvent(target, event);\n  } else {\n    target.dispatchEvent(event);\n  }\n}\n\nconst Root = DismissableLayer;\nconst Branch = DismissableLayerBranch;\n\nexport {\n  DismissableLayer,\n  DismissableLayerBranch,\n  //\n  Root,\n  Branch,\n};\nexport type { DismissableLayerProps };\n"],"names":["node","handleAndDispatchPointerDownOutsideEvent"],"sourceRoot":"","ignoreList":[0,1,2,3,4,5,6,8,9]}