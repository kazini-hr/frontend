{"version":3,"file":"static/chunks/929-a4c60abaa1e8185b.js","mappings":"kKAKA,sCAGM,EAAG,SACH,EAAG,QADA,CAET,UADS,EACT,CACA,aACA,OACA,IACA,IACA,CAAC,CACD,GACA,aACA,aACA,aACA,YACA,EACA,GACA,YACA,WACA,EAIA,SAAS,EAAQ,KACjB,mBADiB,MACjB,QACA,CACA,SAAS,EAAO,GAChB,oBADgB,EAEhB,CACA,SAAS,EAAY,GACrB,uBAEA,EAHqB,OAGrB,KACA,qBACA,CACA,cACA,8BACA,CACA,SAAS,EAAW,GACpB,wBADoB,OACpB,CAAoC,EAAO,WAC3C,CAqBA,SAAS,EAtBkC,CAsBL,EACtC,sCACA,CA6BA,GA/BsC,MA+BtC,KACA,kDACA,CAUA,SAAS,EAAgB,GACzB,yBATA,CACA,GAOyB,CAPzB,EACA,QACA,SACA,OACA,GAIA,IACA,MACA,QACA,SACA,MACA,CACA,CACA,SAAS,EAAgB,GACzB,IACA,IACA,IACA,QACA,SALyB,CAMrB,EACJ,OACA,QACA,SACA,MACA,OACA,UACA,WACA,IACA,GACA,CACA,CCpIA,kBACA,IAYA,EAZA,CACA,YACA,WACA,CAAI,EACJ,EAAmB,EAAW,GAC9B,EDuCA,ICvCwC,IACxC,EAAsB,EAAa,EADX,CAExB,EAAe,EAAO,GACtB,CAFmC,CAEnC,QACA,UAFsB,GAEtB,aACA,4BACA,gBAEA,UACA,UACA,GACA,IACA,gBAEA,KACA,cACA,GACA,IACA,cACA,EACA,KACA,aACA,GACA,cACA,GACA,EACA,KACA,YACA,GACA,cACA,GACA,EACA,KACA,SACA,GACA,MACA,KACA,CACA,CACA,OAAU,EAAY,IACtB,YACA,oBACA,KACA,WACA,mBAEA,CACA,QACA,CASA,qBACA,IACA,qBACA,sBACA,gBACA,WACA,CAAI,EACJ,oBACA,0CACA,2BACA,YACA,WACA,UACA,CAAG,EACH,CACA,IACA,IACA,CAAI,SACJ,IACA,KACA,IACA,YAAkB,WAA4B,KAC9C,IACA,OACA,KACA,CAAM,KACN,CACA,IACA,IACA,OACA,QACA,CAAM,SACN,IACA,IACA,mBACA,YACA,WACA,iBACA,QACA,WACA,UACA,YACA,UACA,CACA,CAAK,EACL,cACA,cACA,GACA,KACA,KACA,QACA,KAEA,EACA,WACA,IACA,qBACA,aACA,gBAEA,SACA,yCACA,YACA,WACA,UACA,CAAW,WAEX,CACA,IACA,IACA,CAAU,UAEV,KAEA,CACA,OACA,IACA,IACA,YACA,WACA,gBACA,CACA,EAUA,sBACA,KACA,aACA,OAEA,IACA,IACA,IACA,WACA,QACA,WACA,WACA,CAAI,EACJ,CACA,+BACA,0BACA,4BACA,iBACA,YACA,CAAI,EAAU,KACd,EAAwB,EAAgB,GAExC,MADA,MAFc,OAEd,UADwC,IACxC,WACA,GACA,EAA6B,EAAgB,yBAC7C,OAD6C,CAC7C,4JACA,WACA,eACA,UACA,CAAG,GACH,kBACA,IACA,IACA,uBACA,0BACI,YACJ,uEACA,mGACA,IACA,GACA,EAAI,EAIwB,EAAgB,uHAC5C,WACA,OACA,eACA,UACA,CAAG,KACH,OACA,4BACA,wCACA,gCACA,oCAEA,CAyTA,gBACA,OACA,mBACA,sBACA,yBACA,oBAEA,CACA,cACA,OAAS,EAAK,gBACd,CAiMA,sBACA,IACA,YACA,WACA,WACA,CAAI,EACJ,mDACA,EAAe,EAAO,GACtB,EAAoB,EAAY,GAChC,EAAgC,MAAX,EAAW,GAChC,YAFgC,IAEhC,QADgC,CAChC,SACA,YACA,EAAmB,EAAQ,KAG3B,CACA,WACA,OAL2B,GAK3B,EACA,gBACA,CAAI,oBACJ,WACA,YACA,kBACA,EAAI,CACJ,uBACA,yBACA,+BAKA,OAHA,uBACA,qBAEA,GACA,MACA,KACA,EAAI,CACJ,MACA,KACA,CACA,CC/vBA,aACA,gCACA,CACA,qBACA,KACA,+BAKA,WACA,CACA,cACA,MACA,uEACA,CACA,cACA,MACA,6FAEA,oBACA,OAGA,2CACA,CACA,oBACA,OAGA,iDACA,CACA,oBACA,OAGA,yDACA,CACA,oBACA,uCAGA,uDACA,CACA,cACA,IACA,WACA,YACA,YACA,UACA,CAAI,KACJ,uFACA,CAIA,cACA,0CACA,IACA,mBACA,CAAM,SACN,QACA,CACA,CAAG,CACH,CACA,cACA,UACA,cAIA,yZACA,CAaA,mBACA,yCACA,8CACA,CACA,cACA,gDACA,CACA,cACA,+BACA,CACA,qBACA,KACA,CACA,wBACA,uBAGA,CACA,qBACA,oBAEA,CACA,cACA,iBACA,SAEA,MAEA,gBAEA,cAEA,cAEA,KACA,oBACA,CAWA,kBACA,KACA,aACA,OAEA,YACA,OAEA,MAlBA,cACA,kBACA,KACA,4CAEA,WACA,EAEA,IACA,EASA,GACA,gDACA,OACA,MACA,WACA,8DACA,CACA,4BACA,CACA,cACA,oEACA,CClJA,cACA,MAAc,EAAgB,GAG9B,WAH8B,EAG9B,YACA,0BACA,EAAoB,EAAa,GACjC,QADiC,SACjC,GACA,qBACA,EAAyB,EAAK,QAA2B,EAAK,OAK9D,OAJA,IACA,IACA,KAEA,CACA,QACA,SACA,GACA,CACA,CAEA,cACA,SAAmB,sBAGnB,cACA,WACA,IAAO,EAAa,GACpB,OAAW,CADS,CACG,GAEvB,OAFuB,CAEvB,wBACA,CACA,QACA,SACA,IACA,CAAI,KACJ,KAAe,EAAK,oBACpB,KAAe,EAAK,sBAUpB,OANA,uBACA,MAEA,uBACA,MAEA,CACA,IACA,GACA,CACA,CAEA,MAA+B,EAAY,GAC3C,OAD2C,EAC3C,KACA,MAAc,EAAS,UACvB,KAAe,iBAGf,CACA,8BACA,8BAJA,CAMA,CAWA,wBAVA,CAWA,aACA,OAEA,YACA,OAEA,gCACA,OACA,EAAc,EAAY,GAC1B,IACA,EACU,CAHgB,CAGP,IACnB,GADmB,EACnB,IAGA,QAGA,OA5BA,UADA,EA6BA,IA3BA,OA2BA,GAzBA,KAyBA,IAzBmE,EAyBnE,EAzB4E,GAG5E,EAH4E,CAyB5E,KAA2H,EAAY,GACvI,OADuI,EACvI,UACA,kBACA,cACA,eACA,MACA,MAAgB,EAAS,GACzB,IADyB,CACa,EAAS,GAAiB,EAAS,EAA1B,CAA0B,EACzE,EADyE,EAEzE,EAAwB,EAAe,GACvC,UADuC,CACvC,QACA,WACA,4BACA,EAAkB,EAAgB,GAC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CACA,CAAC,EEqbK,GAAe,UAIrB,cACA,GACA,CANqB,QAMrB,GACA,MAEA,GACA,cACA,IACA,EACA,OAAS,EAAiB,KAC1B,KACA,GAF0B,MAE1B,CACA,CAAG,CACH,iBCvuBA,gCAA8C,iBAAe,CAAG,WAAS,CAIzE,qBAUA,EACA,EACA,EAXA,SACA,SAEA,sBACA,SAEA,qDACA,SAKA,6BACA,qBAEA,GADA,eACA,kBACA,QAAuB,EAAU,CAAV,KACvB,kBACA,SAGA,QACA,CAGA,GADA,GADA,mBACA,UACA,sBACA,SAEA,QAAqB,EAAU,CAAV,KACrB,QAAa,6BACb,SAGA,QAAqB,EAAU,CAAV,KAAU,CAC/B,WACA,gCAGA,eACA,QAEA,CACA,QACA,CACA,iBACA,CAEA,qBACA,2BACA,EAEA,sCACA,mBACA,CAEA,iBACA,YACA,wBACA,CAEA,eACA,MAAc,QAAY,IAI1B,OAHA,QACA,WACA,CAAG,EACH,CACA,CAoKA,UAIA,EACA,aACA,UACA,MACA,IACA,UACA,UACA,CAAQ,mCACR,GAVA,IAAa,qBAUb,EAVa,WAWb,gBACiB,GAAO,CACxB,iBADwB,CAExB,SACA,CAAW,QAEX,GAEA,EACe,GAAO,CACtB,UACA,OAFsB,CAEtB,CACA,CAAS,QAET,EACA,CACA,GAUM,GAAM,SACZ,GH+eA,YAIA,CGpfY,MHifZ,GGhfa,EHgfb,OACA,MAEA,CACA,cACA,UACA,YACA,QACA,IACA,IACA,IACA,YACA,iBACA,CAAQ,EACR,sBAIA,kFACA,GAEA,CACA,QACA,QACA,MACA,KACA,WACA,CACA,CACA,CACA,CACA,EG/gBa,GACb,cACA,CAAC,CAOK,GAAK,SACX,GH4gBA,YAIA,OAHA,EG7gBY,GH6gBZ,OACA,OAEA,CACA,aACA,UACA,YACA,IACA,IACA,IACA,YACA,CAAQ,EACR,CACA,cACA,eACA,WACA,OACA,IACA,IACA,IACA,CAAc,EACd,OACA,IACA,GACA,CACA,CACA,CAAS,CACT,KACA,CAAQ,EAAU,KAClB,GACA,IACA,GACA,EACA,OALkB,CAKlB,OACA,EAAwB,EAAY,EAAO,IAC3C,EAAuB,EAAe,GACtC,OACA,GAFsC,CAEtC,CAH2C,CAG3C,CAHmC,GAInC,GACA,2BACA,2BACA,SACA,SACA,EDh0BS,ECg0BoB,SAC7B,CACA,EAFwB,CAExB,GACA,CAH6B,EDh0BjB,CCm0BZ,uBACA,2BACA,SACA,SACA,IAA8B,EDv0BV,ECu0BU,KAC9B,CACA,GAFyB,CAEzB,IAF8B,EAE9B,EACA,CD10BuB,EC00BvB,EACA,MACA,KACA,CAAO,EACP,OACA,KACA,MACA,QACA,QACA,SACA,MACA,KACA,CACA,CACA,CACA,CACA,CACA,EGnlBY,GACZ,cACA,CAAC,CAKK,GAAU,SAChB,GAAK,SH+kBL,GAIA,KGplBgB,EHilBhB,OGhlBiB,EHglBjB,GACA,OAEA,CACA,UACA,MACA,IACA,IACA,IACA,YACA,QACA,iBACA,CAAQ,EACR,CACA,WACA,cACA,eACA,CAAQ,EAAU,KAClB,GACA,IACA,GACA,EACA,EAAwB,EAAW,GALjB,EAMK,EAAe,GACtC,OACA,OACA,EAAwB,CAJW,CAIH,KAChC,mBADgC,EAChC,CACA,WACA,WACA,EAAQ,CACR,WACA,YACA,MAEA,MACA,+BACA,0CACA,2CACA,IACA,IACU,KACV,KAEA,CACA,MACA,QACA,+BACA,0BAAsD,EAAO,IAC7D,mBAD6D,QAC7D,+DACA,2FACA,KACA,IACU,KACV,KAEA,CACA,OACA,MACA,KACA,CACA,CACA,CACA,EG/oBiB,GACjB,cACA,CAAC,CAQK,GAAI,SACV,GHgGA,WGjGU,CHqGV,OAHA,CGjGW,IHiGX,OACA,OAEA,CACA,YACA,UACA,gBACA,IAqDA,IAyBA,EA7EA,IACA,YACA,iBACA,QACA,mBACA,WACA,WACA,CAAQ,EACR,CACA,cACA,eACA,qBACA,6BACA,mCACA,mBACA,KACA,CAAQ,EAAU,KAMlB,mBANkB,GAMlB,kBACA,SAEA,MAAmB,EAAO,GAC1B,EAA8B,EAAW,GACzC,EAA8B,EAAO,OACrC,EAH0B,MAG1B,KAFyC,EAEzC,CADqC,CACrC,kCACA,aAAsG,EAAoB,ID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T,CAAS,EAE1C,CAHoF,CAG5D,CAC5B,QAAS,EACT,SAAU,EAAS,OAAO,IAE1B,KAFmC,OAEtB,CACf,EAEM,MAAE,iBAAM,YAAgB,EAAW,8BAAc,EAAe,CH1F1E,WG0FyF,CHzFzF,YACA,OAEA,IACA,qBACA,sBACA,gBACA,WACA,UACA,YACA,WACA,CAAM,EAAI,CACV,eACA,uBACA,OACA,CAAI,EACJ,MAA0B,UAAc,EACxC,IACA,IACA,WACA,YACA,iBAAsB,CACtB,eACA,CAAG,EACH,MAAkD,UAAc,IAChE,SACA,KAEA,SAAsC,UAAc,OACpD,MAAoC,UAAc,OAClD,EAAuB,aAAiB,KACxC,gBACA,YACA,KAEA,CAAG,KACH,EAAsB,aAAiB,KACvC,gBACA,YACA,KAEA,CAAG,KACH,OACA,OACA,EAAuB,QAAY,OACnC,EAAsB,QAAY,OAClC,EAAkB,QAAY,IAC9B,UACA,QACA,QACA,QACA,EAAiB,aAAiB,MAClC,0BACA,OAEA,OACA,YACA,WACA,YACA,CACA,YACA,uBAEI,GAAe,gCACnB,OACA,KAKA,4BAEA,+BACA,YACQ,YAAkB,MAC1B,IACA,CAAS,EAET,CAAK,CACL,CAAG,cACH,QACA,iCACA,0BACA,OACA,KACA,eACA,EAAO,EAEP,CAAG,MACH,MAAuB,QAAY,KACnC,QACA,aACA,KACA,YACA,GACG,IACH,QAGA,GAFA,iBACA,iBACA,MACA,aACA,wBAEA,GACA,CACA,CAAG,cACH,MAAe,SAAa,OAC5B,YACA,WACA,eACA,aACA,EAAG,QACH,EAAmB,SAAa,OAChC,YACA,UACA,EAAG,QACH,EAAyB,SAAa,MACtC,OACA,WACA,OACA,KACA,EACA,eACA,SAEA,yBACA,4BACA,EACA,CACA,KACA,wCACA,yBACA,sBACA,CAAS,EAGT,CACA,WACA,OACA,KACA,CACA,CAAG,2BACH,OAAS,SAAa,OACtB,KACA,SACA,OACA,WACA,gBACA,EAAG,aACH,EG5D0F,CAEpF,SAAU,QACV,UApBwB,CAoBb,CApBqB,cAAqB,IAAM,EAAQ,IAqBnE,qBAAsB,6DAAI,IAAS,cAI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","sources":["webpack://_N_E/./node_modules/.pnpm/@floating-ui+utils@0.2.9/node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs","webpack://_N_E/./node_modules/.pnpm/@floating-ui+core@1.6.9/node_modules/@floating-ui/core/dist/floating-ui.core.mjs","webpack://_N_E/./node_modules/.pnpm/@floating-ui+utils@0.2.9/node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs","webpack://_N_E/./node_modules/.pnpm/@floating-ui+dom@1.6.13/node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs","webpack://_N_E/./node_modules/.pnpm/@floating-ui+react-dom@2.1.2_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs","webpack://_N_E/./node_modules/.pnpm/@radix-ui+react-arrow@1.1.7_@types+react-dom@19.0.4_@types+react@19.0.12__@types+react@_03e2402922b8c4adae4f663e33d53881/node_modules/@radix-ui/react-arrow/dist/index.mjs","webpack://_N_E/./node_modules/.pnpm/@radix-ui+react-use-size@1.1.1_@types+react@19.0.12_react@19.0.0/node_modules/@radix-ui/react-use-size/dist/index.mjs","webpack://_N_E/../src/popper.tsx","webpack://_N_E/./node_modules/.pnpm/@radix-ui+number@1.1.1/node_modules/@radix-ui/number/dist/index.mjs","webpack://_N_E/./node_modules/.pnpm/@radix-ui+react-use-previous@1.1.1_@types+react@19.0.12_react@19.0.0/node_modules/@radix-ui/react-use-previous/dist/index.mjs","webpack://_N_E/../src/select.tsx","webpack://_N_E/../../../src/icons/chevron-up.ts","webpack://_N_E/./node_modules/.pnpm/@radix-ui+react-direction@1.1.1_@types+react@19.0.12_react@19.0.0/node_modules/@radix-ui/react-direction/dist/index.mjs","webpack://_N_E/../../../src/icons/check.ts","webpack://_N_E/../../../src/icons/chevron-down.ts"],"sourcesContent":["/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n","import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    x,\n    y,\n    width: rects.floating.width,\n    height: rects.floating.height\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const initialSideAxis = getSideAxis(initialPlacement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';\n      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$filter2;\n                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {\n                  if (hasFallbackAxisSideDirection) {\n                    const currentSideAxis = getSideAxis(d.placement);\n                    return currentSideAxis === initialSideAxis ||\n                    // Create a bias to the `y` side axis due to horizontal\n                    // reading directions favoring greater width.\n                    currentSideAxis === 'y';\n                  }\n                  return true;\n                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: rawValue.mainAxis || 0,\n    crossAxis: rawValue.crossAxis || 0,\n    alignmentAxis: rawValue.alignmentAxis\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y,\n          enabled: {\n            [mainAxis]: checkMainAxis,\n            [crossAxis]: checkCrossAxis\n          }\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      var _state$middlewareData, _state$middlewareData2;\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const maximumClippingHeight = height - overflow.top - overflow.bottom;\n      const maximumClippingWidth = width - overflow.left - overflow.right;\n      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);\n      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {\n        availableWidth = maximumClippingWidth;\n      }\n      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {\n        availableHeight = maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n","function hasWindow() {\n  return typeof window !== 'undefined';\n}\nfunction getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  if (!hasWindow()) {\n    return false;\n  }\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  if (!hasWindow() || typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isTopLayer(element) {\n  return [':popover-open', ':modal'].some(selector => {\n    try {\n      return element.matches(selector);\n    } catch (e) {\n      return false;\n    }\n  });\n}\nfunction isContainingBlock(elementOrCss) {\n  const webkit = isWebKit();\n  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  // https://drafts.csswg.org/css-transforms-2/#individual-transforms\n  return ['transform', 'translate', 'scale', 'rotate', 'perspective'].some(value => css[value] ? css[value] !== 'none' : false) || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'translate', 'scale', 'rotate', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else if (isTopLayer(currentNode)) {\n      return null;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    const frameElement = getFrameElement(win);\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getFrameElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isTopLayer, isWebKit };\n","import { rectToClientRect, detectOverflow as detectOverflow$1, offset as offset$1, autoPlacement as autoPlacement$1, shift as shift$1, flip as flip$1, size as size$1, hide as hide$1, arrow as arrow$1, inline as inline$1, limitShift as limitShift$1, computePosition as computePosition$1 } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getFrameElement, getNodeScroll, getDocumentElement, isTopLayer, getNodeName, isOverflowElement, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = getFrameElement(currentWin);\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = getFrameElement(currentWin);\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\n// If <html> has a CSS width greater than the viewport, then this will be\n// incorrect for RTL.\nfunction getWindowScrollBarX(element, rect) {\n  const leftScroll = getNodeScroll(element).scrollLeft;\n  if (!rect) {\n    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;\n  }\n  return rect.left + leftScroll;\n}\n\nfunction getHTMLOffset(documentElement, scroll, ignoreScrollbarX) {\n  if (ignoreScrollbarX === void 0) {\n    ignoreScrollbarX = false;\n  }\n  const htmlRect = documentElement.getBoundingClientRect();\n  const x = htmlRect.left + scroll.scrollLeft - (ignoreScrollbarX ? 0 :\n  // RTL <body> scrollbar.\n  getWindowScrollBarX(documentElement, htmlRect));\n  const y = htmlRect.top + scroll.scrollTop;\n  return {\n    x,\n    y\n  };\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll, true) : createCoords(0);\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x + htmlOffset.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y + htmlOffset.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y,\n      width: clippingAncestor.width,\n      height: clippingAncestor.height\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      // If the <body> scrollbar appears on the left (e.g. RTL systems). Use\n      // Firefox with layout.scrollbar.side = 3 in about:config to test this.\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll) : createCoords(0);\n  const x = rect.left + scroll.scrollLeft - offsets.x - htmlOffset.x;\n  const y = rect.top + scroll.scrollTop - offsets.y - htmlOffset.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction isStaticPositioned(element) {\n  return getComputedStyle(element).position === 'static';\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  let rawOffsetParent = element.offsetParent;\n\n  // Firefox returns the <html> element as the offsetParent if it's non-static,\n  // while Chrome and Safari return the <body> element. The <body> element must\n  // be used to perform the correct calculations even if the <html> element is\n  // non-static.\n  if (getDocumentElement(element) === rawOffsetParent) {\n    rawOffsetParent = rawOffsetParent.ownerDocument.body;\n  }\n  return rawOffsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const win = getWindow(element);\n  if (isTopLayer(element)) {\n    return win;\n  }\n  if (!isHTMLElement(element)) {\n    let svgOffsetParent = getParentNode(element);\n    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = getParentNode(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {\n    return win;\n  }\n  return offsetParent || getContainingBlock(element) || win;\n}\n\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  const floatingDimensions = await getDimensionsFn(data.floating);\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      width: floatingDimensions.width,\n      height: floatingDimensions.height\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\nfunction rectsAreEqual(a, b) {\n  return a.x === b.x && a.y === b.y && a.width === b.width && a.height === b.height;\n}\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const elementRectForRootMargin = element.getBoundingClientRect();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = elementRectForRootMargin;\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          // If the reference is clipped, the ratio is 0. Throttle the refresh\n          // to prevent an infinite loop of updates.\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1000);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {\n        // It's possible that even though the ratio is reported as 1, the\n        // element is not actually fully within the IntersectionObserver's root\n        // area anymore. This can happen under performance constraints. This may\n        // be a bug in the browser's IntersectionObserver implementation. To\n        // work around this, we compare the element's bounding rect now with\n        // what it was at the time we created the IntersectionObserver. If they\n        // are not equal then the element moved, so we refresh.\n        refresh();\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nconst detectOverflow = detectOverflow$1;\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = offset$1;\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = autoPlacement$1;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = shift$1;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = flip$1;\n\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = size$1;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = hide$1;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = arrow$1;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = inline$1;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = limitShift$1;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, platform, shift, size };\n","import { computePosition, arrow as arrow$2, offset as offset$1, shift as shift$1, limitShift as limitShift$1, flip as flip$1, size as size$1, autoPlacement as autoPlacement$1, hide as hide$1, inline as inline$1 } from '@floating-ui/dom';\nexport { autoUpdate, computePosition, detectOverflow, getOverflowAncestors, platform } from '@floating-ui/dom';\nimport * as React from 'react';\nimport { useLayoutEffect, useEffect } from 'react';\nimport * as ReactDOM from 'react-dom';\n\nvar index = typeof document !== 'undefined' ? useLayoutEffect : useEffect;\n\n// Fork of `fast-deep-equal` that only does the comparisons we need and compares\n// functions\nfunction deepEqual(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (typeof a !== typeof b) {\n    return false;\n  }\n  if (typeof a === 'function' && a.toString() === b.toString()) {\n    return true;\n  }\n  let length;\n  let i;\n  let keys;\n  if (a && b && typeof a === 'object') {\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length !== b.length) return false;\n      for (i = length; i-- !== 0;) {\n        if (!deepEqual(a[i], b[i])) {\n          return false;\n        }\n      }\n      return true;\n    }\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) {\n      return false;\n    }\n    for (i = length; i-- !== 0;) {\n      if (!{}.hasOwnProperty.call(b, keys[i])) {\n        return false;\n      }\n    }\n    for (i = length; i-- !== 0;) {\n      const key = keys[i];\n      if (key === '_owner' && a.$$typeof) {\n        continue;\n      }\n      if (!deepEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return a !== a && b !== b;\n}\n\nfunction getDPR(element) {\n  if (typeof window === 'undefined') {\n    return 1;\n  }\n  const win = element.ownerDocument.defaultView || window;\n  return win.devicePixelRatio || 1;\n}\n\nfunction roundByDPR(element, value) {\n  const dpr = getDPR(element);\n  return Math.round(value * dpr) / dpr;\n}\n\nfunction useLatestRef(value) {\n  const ref = React.useRef(value);\n  index(() => {\n    ref.current = value;\n  });\n  return ref;\n}\n\n/**\n * Provides data to position a floating element.\n * @see https://floating-ui.com/docs/useFloating\n */\nfunction useFloating(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform,\n    elements: {\n      reference: externalReference,\n      floating: externalFloating\n    } = {},\n    transform = true,\n    whileElementsMounted,\n    open\n  } = options;\n  const [data, setData] = React.useState({\n    x: 0,\n    y: 0,\n    strategy,\n    placement,\n    middlewareData: {},\n    isPositioned: false\n  });\n  const [latestMiddleware, setLatestMiddleware] = React.useState(middleware);\n  if (!deepEqual(latestMiddleware, middleware)) {\n    setLatestMiddleware(middleware);\n  }\n  const [_reference, _setReference] = React.useState(null);\n  const [_floating, _setFloating] = React.useState(null);\n  const setReference = React.useCallback(node => {\n    if (node !== referenceRef.current) {\n      referenceRef.current = node;\n      _setReference(node);\n    }\n  }, []);\n  const setFloating = React.useCallback(node => {\n    if (node !== floatingRef.current) {\n      floatingRef.current = node;\n      _setFloating(node);\n    }\n  }, []);\n  const referenceEl = externalReference || _reference;\n  const floatingEl = externalFloating || _floating;\n  const referenceRef = React.useRef(null);\n  const floatingRef = React.useRef(null);\n  const dataRef = React.useRef(data);\n  const hasWhileElementsMounted = whileElementsMounted != null;\n  const whileElementsMountedRef = useLatestRef(whileElementsMounted);\n  const platformRef = useLatestRef(platform);\n  const openRef = useLatestRef(open);\n  const update = React.useCallback(() => {\n    if (!referenceRef.current || !floatingRef.current) {\n      return;\n    }\n    const config = {\n      placement,\n      strategy,\n      middleware: latestMiddleware\n    };\n    if (platformRef.current) {\n      config.platform = platformRef.current;\n    }\n    computePosition(referenceRef.current, floatingRef.current, config).then(data => {\n      const fullData = {\n        ...data,\n        // The floating element's position may be recomputed while it's closed\n        // but still mounted (such as when transitioning out). To ensure\n        // `isPositioned` will be `false` initially on the next open, avoid\n        // setting it to `true` when `open === false` (must be specified).\n        isPositioned: openRef.current !== false\n      };\n      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {\n        dataRef.current = fullData;\n        ReactDOM.flushSync(() => {\n          setData(fullData);\n        });\n      }\n    });\n  }, [latestMiddleware, placement, strategy, platformRef, openRef]);\n  index(() => {\n    if (open === false && dataRef.current.isPositioned) {\n      dataRef.current.isPositioned = false;\n      setData(data => ({\n        ...data,\n        isPositioned: false\n      }));\n    }\n  }, [open]);\n  const isMountedRef = React.useRef(false);\n  index(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n    };\n  }, []);\n  index(() => {\n    if (referenceEl) referenceRef.current = referenceEl;\n    if (floatingEl) floatingRef.current = floatingEl;\n    if (referenceEl && floatingEl) {\n      if (whileElementsMountedRef.current) {\n        return whileElementsMountedRef.current(referenceEl, floatingEl, update);\n      }\n      update();\n    }\n  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);\n  const refs = React.useMemo(() => ({\n    reference: referenceRef,\n    floating: floatingRef,\n    setReference,\n    setFloating\n  }), [setReference, setFloating]);\n  const elements = React.useMemo(() => ({\n    reference: referenceEl,\n    floating: floatingEl\n  }), [referenceEl, floatingEl]);\n  const floatingStyles = React.useMemo(() => {\n    const initialStyles = {\n      position: strategy,\n      left: 0,\n      top: 0\n    };\n    if (!elements.floating) {\n      return initialStyles;\n    }\n    const x = roundByDPR(elements.floating, data.x);\n    const y = roundByDPR(elements.floating, data.y);\n    if (transform) {\n      return {\n        ...initialStyles,\n        transform: \"translate(\" + x + \"px, \" + y + \"px)\",\n        ...(getDPR(elements.floating) >= 1.5 && {\n          willChange: 'transform'\n        })\n      };\n    }\n    return {\n      position: strategy,\n      left: x,\n      top: y\n    };\n  }, [strategy, transform, elements.floating, data.x, data.y]);\n  return React.useMemo(() => ({\n    ...data,\n    update,\n    refs,\n    elements,\n    floatingStyles\n  }), [data, update, refs, elements, floatingStyles]);\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow$1 = options => {\n  function isRef(value) {\n    return {}.hasOwnProperty.call(value, 'current');\n  }\n  return {\n    name: 'arrow',\n    options,\n    fn(state) {\n      const {\n        element,\n        padding\n      } = typeof options === 'function' ? options(state) : options;\n      if (element && isRef(element)) {\n        if (element.current != null) {\n          return arrow$2({\n            element: element.current,\n            padding\n          }).fn(state);\n        }\n        return {};\n      }\n      if (element) {\n        return arrow$2({\n          element,\n          padding\n        }).fn(state);\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = (options, deps) => ({\n  ...offset$1(options),\n  options: [options, deps]\n});\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = (options, deps) => ({\n  ...shift$1(options),\n  options: [options, deps]\n});\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = (options, deps) => ({\n  ...limitShift$1(options),\n  options: [options, deps]\n});\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = (options, deps) => ({\n  ...flip$1(options),\n  options: [options, deps]\n});\n\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = (options, deps) => ({\n  ...size$1(options),\n  options: [options, deps]\n});\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = (options, deps) => ({\n  ...autoPlacement$1(options),\n  options: [options, deps]\n});\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = (options, deps) => ({\n  ...hide$1(options),\n  options: [options, deps]\n});\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = (options, deps) => ({\n  ...inline$1(options),\n  options: [options, deps]\n});\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * This wraps the core `arrow` middleware to allow React refs as the element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = (options, deps) => ({\n  ...arrow$1(options),\n  options: [options, deps]\n});\n\nexport { arrow, autoPlacement, flip, hide, inline, limitShift, offset, shift, size, useFloating };\n","// src/arrow.tsx\nimport * as React from \"react\";\nimport { Primitive } from \"@radix-ui/react-primitive\";\nimport { jsx } from \"react/jsx-runtime\";\nvar NAME = \"Arrow\";\nvar Arrow = React.forwardRef((props, forwardedRef) => {\n  const { children, width = 10, height = 5, ...arrowProps } = props;\n  return /* @__PURE__ */ jsx(\n    Primitive.svg,\n    {\n      ...arrowProps,\n      ref: forwardedRef,\n      width,\n      height,\n      viewBox: \"0 0 30 10\",\n      preserveAspectRatio: \"none\",\n      children: props.asChild ? children : /* @__PURE__ */ jsx(\"polygon\", { points: \"0,0 30,0 15,10\" })\n    }\n  );\n});\nArrow.displayName = NAME;\nvar Root = Arrow;\nexport {\n  Arrow,\n  Root\n};\n//# sourceMappingURL=index.mjs.map\n","// packages/react/use-size/src/use-size.tsx\nimport * as React from \"react\";\nimport { useLayoutEffect } from \"@radix-ui/react-use-layout-effect\";\nfunction useSize(element) {\n  const [size, setSize] = React.useState(void 0);\n  useLayoutEffect(() => {\n    if (element) {\n      setSize({ width: element.offsetWidth, height: element.offsetHeight });\n      const resizeObserver = new ResizeObserver((entries) => {\n        if (!Array.isArray(entries)) {\n          return;\n        }\n        if (!entries.length) {\n          return;\n        }\n        const entry = entries[0];\n        let width;\n        let height;\n        if (\"borderBoxSize\" in entry) {\n          const borderSizeEntry = entry[\"borderBoxSize\"];\n          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;\n          width = borderSize[\"inlineSize\"];\n          height = borderSize[\"blockSize\"];\n        } else {\n          width = element.offsetWidth;\n          height = element.offsetHeight;\n        }\n        setSize({ width, height });\n      });\n      resizeObserver.observe(element, { box: \"border-box\" });\n      return () => resizeObserver.unobserve(element);\n    } else {\n      setSize(void 0);\n    }\n  }, [element]);\n  return size;\n}\nexport {\n  useSize\n};\n//# sourceMappingURL=index.mjs.map\n","import * as React from 'react';\nimport {\n  useFloating,\n  autoUpdate,\n  offset,\n  shift,\n  limitShift,\n  hide,\n  arrow as floatingUIarrow,\n  flip,\n  size,\n} from '@floating-ui/react-dom';\nimport * as ArrowPrimitive from '@radix-ui/react-arrow';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { useSize } from '@radix-ui/react-use-size';\n\nimport type { Placement, Middleware } from '@floating-ui/react-dom';\nimport type { Scope } from '@radix-ui/react-context';\nimport type { Measurable } from '@radix-ui/rect';\n\nconst SIDE_OPTIONS = ['top', 'right', 'bottom', 'left'] as const;\nconst ALIGN_OPTIONS = ['start', 'center', 'end'] as const;\n\ntype Side = (typeof SIDE_OPTIONS)[number];\ntype Align = (typeof ALIGN_OPTIONS)[number];\n\n/* -------------------------------------------------------------------------------------------------\n * Popper\n * -----------------------------------------------------------------------------------------------*/\n\nconst POPPER_NAME = 'Popper';\n\ntype ScopedProps<P> = P & { __scopePopper?: Scope };\nconst [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME);\n\ntype PopperContextValue = {\n  anchor: Measurable | null;\n  onAnchorChange(anchor: Measurable | null): void;\n};\nconst [PopperProvider, usePopperContext] = createPopperContext<PopperContextValue>(POPPER_NAME);\n\ninterface PopperProps {\n  children?: React.ReactNode;\n}\nconst Popper: React.FC<PopperProps> = (props: ScopedProps<PopperProps>) => {\n  const { __scopePopper, children } = props;\n  const [anchor, setAnchor] = React.useState<Measurable | null>(null);\n  return (\n    <PopperProvider scope={__scopePopper} anchor={anchor} onAnchorChange={setAnchor}>\n      {children}\n    </PopperProvider>\n  );\n};\n\nPopper.displayName = POPPER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * PopperAnchor\n * -----------------------------------------------------------------------------------------------*/\n\nconst ANCHOR_NAME = 'PopperAnchor';\n\ntype PopperAnchorElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface PopperAnchorProps extends PrimitiveDivProps {\n  virtualRef?: React.RefObject<Measurable>;\n}\n\nconst PopperAnchor = React.forwardRef<PopperAnchorElement, PopperAnchorProps>(\n  (props: ScopedProps<PopperAnchorProps>, forwardedRef) => {\n    const { __scopePopper, virtualRef, ...anchorProps } = props;\n    const context = usePopperContext(ANCHOR_NAME, __scopePopper);\n    const ref = React.useRef<PopperAnchorElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n\n    React.useEffect(() => {\n      // Consumer can anchor the popper to something that isn't\n      // a DOM node e.g. pointer position, so we override the\n      // `anchorRef` with their virtual ref in this case.\n      context.onAnchorChange(virtualRef?.current || ref.current);\n    });\n\n    return virtualRef ? null : <Primitive.div {...anchorProps} ref={composedRefs} />;\n  }\n);\n\nPopperAnchor.displayName = ANCHOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * PopperContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'PopperContent';\n\ntype PopperContentContextValue = {\n  placedSide: Side;\n  onArrowChange(arrow: HTMLSpanElement | null): void;\n  arrowX?: number;\n  arrowY?: number;\n  shouldHideArrow: boolean;\n};\n\nconst [PopperContentProvider, useContentContext] =\n  createPopperContext<PopperContentContextValue>(CONTENT_NAME);\n\ntype Boundary = Element | null;\n\ntype PopperContentElement = React.ComponentRef<typeof Primitive.div>;\ninterface PopperContentProps extends PrimitiveDivProps {\n  side?: Side;\n  sideOffset?: number;\n  align?: Align;\n  alignOffset?: number;\n  arrowPadding?: number;\n  avoidCollisions?: boolean;\n  collisionBoundary?: Boundary | Boundary[];\n  collisionPadding?: number | Partial<Record<Side, number>>;\n  sticky?: 'partial' | 'always';\n  hideWhenDetached?: boolean;\n  updatePositionStrategy?: 'optimized' | 'always';\n  onPlaced?: () => void;\n}\n\nconst PopperContent = React.forwardRef<PopperContentElement, PopperContentProps>(\n  (props: ScopedProps<PopperContentProps>, forwardedRef) => {\n    const {\n      __scopePopper,\n      side = 'bottom',\n      sideOffset = 0,\n      align = 'center',\n      alignOffset = 0,\n      arrowPadding = 0,\n      avoidCollisions = true,\n      collisionBoundary = [],\n      collisionPadding: collisionPaddingProp = 0,\n      sticky = 'partial',\n      hideWhenDetached = false,\n      updatePositionStrategy = 'optimized',\n      onPlaced,\n      ...contentProps\n    } = props;\n\n    const context = usePopperContext(CONTENT_NAME, __scopePopper);\n\n    const [content, setContent] = React.useState<HTMLDivElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));\n\n    const [arrow, setArrow] = React.useState<HTMLSpanElement | null>(null);\n    const arrowSize = useSize(arrow);\n    const arrowWidth = arrowSize?.width ?? 0;\n    const arrowHeight = arrowSize?.height ?? 0;\n\n    const desiredPlacement = (side + (align !== 'center' ? '-' + align : '')) as Placement;\n\n    const collisionPadding =\n      typeof collisionPaddingProp === 'number'\n        ? collisionPaddingProp\n        : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };\n\n    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];\n    const hasExplicitBoundaries = boundary.length > 0;\n\n    const detectOverflowOptions = {\n      padding: collisionPadding,\n      boundary: boundary.filter(isNotNull),\n      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries\n      altBoundary: hasExplicitBoundaries,\n    };\n\n    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({\n      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues\n      strategy: 'fixed',\n      placement: desiredPlacement,\n      whileElementsMounted: (...args) => {\n        const cleanup = autoUpdate(...args, {\n          animationFrame: updatePositionStrategy === 'always',\n        });\n        return cleanup;\n      },\n      elements: {\n        reference: context.anchor,\n      },\n      middleware: [\n        offset({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),\n        avoidCollisions &&\n          shift({\n            mainAxis: true,\n            crossAxis: false,\n            limiter: sticky === 'partial' ? limitShift() : undefined,\n            ...detectOverflowOptions,\n          }),\n        avoidCollisions && flip({ ...detectOverflowOptions }),\n        size({\n          ...detectOverflowOptions,\n          apply: ({ elements, rects, availableWidth, availableHeight }) => {\n            const { width: anchorWidth, height: anchorHeight } = rects.reference;\n            const contentStyle = elements.floating.style;\n            contentStyle.setProperty('--radix-popper-available-width', `${availableWidth}px`);\n            contentStyle.setProperty('--radix-popper-available-height', `${availableHeight}px`);\n            contentStyle.setProperty('--radix-popper-anchor-width', `${anchorWidth}px`);\n            contentStyle.setProperty('--radix-popper-anchor-height', `${anchorHeight}px`);\n          },\n        }),\n        arrow && floatingUIarrow({ element: arrow, padding: arrowPadding }),\n        transformOrigin({ arrowWidth, arrowHeight }),\n        hideWhenDetached && hide({ strategy: 'referenceHidden', ...detectOverflowOptions }),\n      ],\n    });\n\n    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);\n\n    const handlePlaced = useCallbackRef(onPlaced);\n    useLayoutEffect(() => {\n      if (isPositioned) {\n        handlePlaced?.();\n      }\n    }, [isPositioned, handlePlaced]);\n\n    const arrowX = middlewareData.arrow?.x;\n    const arrowY = middlewareData.arrow?.y;\n    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;\n\n    const [contentZIndex, setContentZIndex] = React.useState<string>();\n    useLayoutEffect(() => {\n      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);\n    }, [content]);\n\n    return (\n      <div\n        ref={refs.setFloating}\n        data-radix-popper-content-wrapper=\"\"\n        style={{\n          ...floatingStyles,\n          transform: isPositioned ? floatingStyles.transform : 'translate(0, -200%)', // keep off the page when measuring\n          minWidth: 'max-content',\n          zIndex: contentZIndex,\n          ['--radix-popper-transform-origin' as any]: [\n            middlewareData.transformOrigin?.x,\n            middlewareData.transformOrigin?.y,\n          ].join(' '),\n\n          // hide the content if using the hide middleware and should be hidden\n          // set visibility to hidden and disable pointer events so the UI behaves\n          // as if the PopperContent isn't there at all\n          ...(middlewareData.hide?.referenceHidden && {\n            visibility: 'hidden',\n            pointerEvents: 'none',\n          }),\n        }}\n        // Floating UI interally calculates logical alignment based the `dir` attribute on\n        // the reference/floating node, we must add this attribute here to ensure\n        // this is calculated when portalled as well as inline.\n        dir={props.dir}\n      >\n        <PopperContentProvider\n          scope={__scopePopper}\n          placedSide={placedSide}\n          onArrowChange={setArrow}\n          arrowX={arrowX}\n          arrowY={arrowY}\n          shouldHideArrow={cannotCenterArrow}\n        >\n          <Primitive.div\n            data-side={placedSide}\n            data-align={placedAlign}\n            {...contentProps}\n            ref={composedRefs}\n            style={{\n              ...contentProps.style,\n              // if the PopperContent hasn't been placed yet (not all measurements done)\n              // we prevent animations so that users's animation don't kick in too early referring wrong sides\n              animation: !isPositioned ? 'none' : undefined,\n            }}\n          />\n        </PopperContentProvider>\n      </div>\n    );\n  }\n);\n\nPopperContent.displayName = CONTENT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * PopperArrow\n * -----------------------------------------------------------------------------------------------*/\n\nconst ARROW_NAME = 'PopperArrow';\n\nconst OPPOSITE_SIDE: Record<Side, Side> = {\n  top: 'bottom',\n  right: 'left',\n  bottom: 'top',\n  left: 'right',\n};\n\ntype PopperArrowElement = React.ComponentRef<typeof ArrowPrimitive.Root>;\ntype ArrowProps = React.ComponentPropsWithoutRef<typeof ArrowPrimitive.Root>;\ninterface PopperArrowProps extends ArrowProps {}\n\nconst PopperArrow = React.forwardRef<PopperArrowElement, PopperArrowProps>(function PopperArrow(\n  props: ScopedProps<PopperArrowProps>,\n  forwardedRef\n) {\n  const { __scopePopper, ...arrowProps } = props;\n  const contentContext = useContentContext(ARROW_NAME, __scopePopper);\n  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];\n\n  return (\n    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)\n    // doesn't report size as we'd expect on SVG elements.\n    // it reports their bounding box which is effectively the largest path inside the SVG.\n    <span\n      ref={contentContext.onArrowChange}\n      style={{\n        position: 'absolute',\n        left: contentContext.arrowX,\n        top: contentContext.arrowY,\n        [baseSide]: 0,\n        transformOrigin: {\n          top: '',\n          right: '0 0',\n          bottom: 'center 0',\n          left: '100% 0',\n        }[contentContext.placedSide],\n        transform: {\n          top: 'translateY(100%)',\n          right: 'translateY(50%) rotate(90deg) translateX(-50%)',\n          bottom: `rotate(180deg)`,\n          left: 'translateY(50%) rotate(-90deg) translateX(50%)',\n        }[contentContext.placedSide],\n        visibility: contentContext.shouldHideArrow ? 'hidden' : undefined,\n      }}\n    >\n      <ArrowPrimitive.Root\n        {...arrowProps}\n        ref={forwardedRef}\n        style={{\n          ...arrowProps.style,\n          // ensures the element can be measured correctly (mostly for if SVG)\n          display: 'block',\n        }}\n      />\n    </span>\n  );\n});\n\nPopperArrow.displayName = ARROW_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction isNotNull<T>(value: T | null): value is T {\n  return value !== null;\n}\n\nconst transformOrigin = (options: { arrowWidth: number; arrowHeight: number }): Middleware => ({\n  name: 'transformOrigin',\n  options,\n  fn(data) {\n    const { placement, rects, middlewareData } = data;\n\n    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;\n    const isArrowHidden = cannotCenterArrow;\n    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;\n    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;\n\n    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);\n    const noArrowAlign = { start: '0%', center: '50%', end: '100%' }[placedAlign];\n\n    const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;\n    const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;\n\n    let x = '';\n    let y = '';\n\n    if (placedSide === 'bottom') {\n      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;\n      y = `${-arrowHeight}px`;\n    } else if (placedSide === 'top') {\n      x = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;\n      y = `${rects.floating.height + arrowHeight}px`;\n    } else if (placedSide === 'right') {\n      x = `${-arrowHeight}px`;\n      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;\n    } else if (placedSide === 'left') {\n      x = `${rects.floating.width + arrowHeight}px`;\n      y = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;\n    }\n    return { data: { x, y } };\n  },\n});\n\nfunction getSideAndAlignFromPlacement(placement: Placement) {\n  const [side, align = 'center'] = placement.split('-');\n  return [side as Side, align as Align] as const;\n}\n\nconst Root = Popper;\nconst Anchor = PopperAnchor;\nconst Content = PopperContent;\nconst Arrow = PopperArrow;\n\nexport {\n  createPopperScope,\n  //\n  Popper,\n  PopperAnchor,\n  PopperContent,\n  PopperArrow,\n  //\n  Root,\n  Anchor,\n  Content,\n  Arrow,\n  //\n  SIDE_OPTIONS,\n  ALIGN_OPTIONS,\n};\nexport type { PopperProps, PopperAnchorProps, PopperContentProps, PopperArrowProps };\n","// packages/core/number/src/number.ts\nfunction clamp(value, [min, max]) {\n  return Math.min(max, Math.max(min, value));\n}\nexport {\n  clamp\n};\n//# sourceMappingURL=index.mjs.map\n","// packages/react/use-previous/src/use-previous.tsx\nimport * as React from \"react\";\nfunction usePrevious(value) {\n  const ref = React.useRef({ value, previous: value });\n  return React.useMemo(() => {\n    if (ref.current.value !== value) {\n      ref.current.previous = ref.current.value;\n      ref.current.value = value;\n    }\n    return ref.current.previous;\n  }, [value]);\n}\nexport {\n  usePrevious\n};\n//# sourceMappingURL=index.mjs.map\n","import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { clamp } from '@radix-ui/number';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createContextScope } from '@radix-ui/react-context';\nimport { useDirection } from '@radix-ui/react-direction';\nimport { DismissableLayer } from '@radix-ui/react-dismissable-layer';\nimport { useFocusGuards } from '@radix-ui/react-focus-guards';\nimport { FocusScope } from '@radix-ui/react-focus-scope';\nimport { useId } from '@radix-ui/react-id';\nimport * as PopperPrimitive from '@radix-ui/react-popper';\nimport { createPopperScope } from '@radix-ui/react-popper';\nimport { Portal as PortalPrimitive } from '@radix-ui/react-portal';\nimport { Primitive } from '@radix-ui/react-primitive';\nimport { createSlot } from '@radix-ui/react-slot';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { usePrevious } from '@radix-ui/react-use-previous';\nimport { VISUALLY_HIDDEN_STYLES } from '@radix-ui/react-visually-hidden';\nimport { hideOthers } from 'aria-hidden';\nimport { RemoveScroll } from 'react-remove-scroll';\n\nimport type { Scope } from '@radix-ui/react-context';\n\ntype Direction = 'ltr' | 'rtl';\n\nconst OPEN_KEYS = [' ', 'Enter', 'ArrowUp', 'ArrowDown'];\nconst SELECTION_KEYS = [' ', 'Enter'];\n\n/* -------------------------------------------------------------------------------------------------\n * Select\n * -----------------------------------------------------------------------------------------------*/\n\nconst SELECT_NAME = 'Select';\n\ntype ItemData = { value: string; disabled: boolean; textValue: string };\nconst [Collection, useCollection, createCollectionScope] = createCollection<\n  SelectItemElement,\n  ItemData\n>(SELECT_NAME);\n\ntype ScopedProps<P> = P & { __scopeSelect?: Scope };\nconst [createSelectContext, createSelectScope] = createContextScope(SELECT_NAME, [\n  createCollectionScope,\n  createPopperScope,\n]);\nconst usePopperScope = createPopperScope();\n\ntype SelectContextValue = {\n  trigger: SelectTriggerElement | null;\n  onTriggerChange(node: SelectTriggerElement | null): void;\n  valueNode: SelectValueElement | null;\n  onValueNodeChange(node: SelectValueElement): void;\n  valueNodeHasChildren: boolean;\n  onValueNodeHasChildrenChange(hasChildren: boolean): void;\n  contentId: string;\n  value: string | undefined;\n  onValueChange(value: string): void;\n  open: boolean;\n  required?: boolean;\n  onOpenChange(open: boolean): void;\n  dir: SelectProps['dir'];\n  triggerPointerDownPosRef: React.MutableRefObject<{ x: number; y: number } | null>;\n  disabled?: boolean;\n};\n\nconst [SelectProvider, useSelectContext] = createSelectContext<SelectContextValue>(SELECT_NAME);\n\ntype NativeOption = React.ReactElement<React.ComponentProps<'option'>>;\n\ntype SelectNativeOptionsContextValue = {\n  onNativeOptionAdd(option: NativeOption): void;\n  onNativeOptionRemove(option: NativeOption): void;\n};\nconst [SelectNativeOptionsProvider, useSelectNativeOptionsContext] =\n  createSelectContext<SelectNativeOptionsContextValue>(SELECT_NAME);\n\ninterface ControlledClearableSelectProps {\n  value: string | undefined;\n  defaultValue?: never;\n  onValueChange: (value: string | undefined) => void;\n}\n\ninterface ControlledUnclearableSelectProps {\n  value: string;\n  defaultValue?: never;\n  onValueChange: (value: string) => void;\n}\n\ninterface UncontrolledSelectProps {\n  value?: never;\n  defaultValue?: string;\n  onValueChange?: {\n    (value: string): void;\n    (value: string | undefined): void;\n  };\n}\n\ntype SelectControlProps =\n  | ControlledClearableSelectProps\n  | ControlledUnclearableSelectProps\n  | UncontrolledSelectProps;\n\ninterface SelectSharedProps {\n  children?: React.ReactNode;\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?(open: boolean): void;\n  dir?: Direction;\n  name?: string;\n  autoComplete?: string;\n  disabled?: boolean;\n  required?: boolean;\n  form?: string;\n}\n\n// TODO: Should improve typing somewhat, but this would be a breaking change.\n// Consider using in the next major version (along with some testing to be sure\n// it works as expected and doesn't cause problems)\ntype _FutureSelectProps = SelectSharedProps & SelectControlProps;\n\ntype SelectProps = SelectSharedProps & {\n  value?: string;\n  defaultValue?: string;\n  onValueChange?(value: string): void;\n};\n\nconst Select: React.FC<SelectProps> = (props: ScopedProps<SelectProps>) => {\n  const {\n    __scopeSelect,\n    children,\n    open: openProp,\n    defaultOpen,\n    onOpenChange,\n    value: valueProp,\n    defaultValue,\n    onValueChange,\n    dir,\n    name,\n    autoComplete,\n    disabled,\n    required,\n    form,\n  } = props;\n  const popperScope = usePopperScope(__scopeSelect);\n  const [trigger, setTrigger] = React.useState<SelectTriggerElement | null>(null);\n  const [valueNode, setValueNode] = React.useState<SelectValueElement | null>(null);\n  const [valueNodeHasChildren, setValueNodeHasChildren] = React.useState(false);\n  const direction = useDirection(dir);\n  const [open, setOpen] = useControllableState({\n    prop: openProp,\n    defaultProp: defaultOpen ?? false,\n    onChange: onOpenChange,\n    caller: SELECT_NAME,\n  });\n  const [value, setValue] = useControllableState({\n    prop: valueProp,\n    defaultProp: defaultValue,\n    onChange: onValueChange as any,\n    caller: SELECT_NAME,\n  });\n  const triggerPointerDownPosRef = React.useRef<{ x: number; y: number } | null>(null);\n\n  // We set this to true by default so that events bubble to forms without JS (SSR)\n  const isFormControl = trigger ? form || !!trigger.closest('form') : true;\n  const [nativeOptionsSet, setNativeOptionsSet] = React.useState(new Set<NativeOption>());\n\n  // The native `select` only associates the correct default value if the corresponding\n  // `option` is rendered as a child **at the same time** as itself.\n  // Because it might take a few renders for our items to gather the information to build\n  // the native `option`(s), we generate a key on the `select` to make sure React re-builds it\n  // each time the options change.\n  const nativeSelectKey = Array.from(nativeOptionsSet)\n    .map((option) => option.props.value)\n    .join(';');\n\n  return (\n    <PopperPrimitive.Root {...popperScope}>\n      <SelectProvider\n        required={required}\n        scope={__scopeSelect}\n        trigger={trigger}\n        onTriggerChange={setTrigger}\n        valueNode={valueNode}\n        onValueNodeChange={setValueNode}\n        valueNodeHasChildren={valueNodeHasChildren}\n        onValueNodeHasChildrenChange={setValueNodeHasChildren}\n        contentId={useId()}\n        value={value}\n        onValueChange={setValue}\n        open={open}\n        onOpenChange={setOpen}\n        dir={direction}\n        triggerPointerDownPosRef={triggerPointerDownPosRef}\n        disabled={disabled}\n      >\n        <Collection.Provider scope={__scopeSelect}>\n          <SelectNativeOptionsProvider\n            scope={props.__scopeSelect}\n            onNativeOptionAdd={React.useCallback((option) => {\n              setNativeOptionsSet((prev) => new Set(prev).add(option));\n            }, [])}\n            onNativeOptionRemove={React.useCallback((option) => {\n              setNativeOptionsSet((prev) => {\n                const optionsSet = new Set(prev);\n                optionsSet.delete(option);\n                return optionsSet;\n              });\n            }, [])}\n          >\n            {children}\n          </SelectNativeOptionsProvider>\n        </Collection.Provider>\n\n        {isFormControl ? (\n          <SelectBubbleInput\n            key={nativeSelectKey}\n            aria-hidden\n            required={required}\n            tabIndex={-1}\n            name={name}\n            autoComplete={autoComplete}\n            value={value}\n            // enable form autofill\n            onChange={(event) => setValue(event.target.value)}\n            disabled={disabled}\n            form={form}\n          >\n            {value === undefined ? <option value=\"\" /> : null}\n            {Array.from(nativeOptionsSet)}\n          </SelectBubbleInput>\n        ) : null}\n      </SelectProvider>\n    </PopperPrimitive.Root>\n  );\n};\n\nSelect.displayName = SELECT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectTrigger\n * -----------------------------------------------------------------------------------------------*/\n\nconst TRIGGER_NAME = 'SelectTrigger';\n\ntype SelectTriggerElement = React.ComponentRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = React.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface SelectTriggerProps extends PrimitiveButtonProps {}\n\nconst SelectTrigger = React.forwardRef<SelectTriggerElement, SelectTriggerProps>(\n  (props: ScopedProps<SelectTriggerProps>, forwardedRef) => {\n    const { __scopeSelect, disabled = false, ...triggerProps } = props;\n    const popperScope = usePopperScope(__scopeSelect);\n    const context = useSelectContext(TRIGGER_NAME, __scopeSelect);\n    const isDisabled = context.disabled || disabled;\n    const composedRefs = useComposedRefs(forwardedRef, context.onTriggerChange);\n    const getItems = useCollection(__scopeSelect);\n    const pointerTypeRef = React.useRef<React.PointerEvent['pointerType']>('touch');\n\n    const [searchRef, handleTypeaheadSearch, resetTypeahead] = useTypeaheadSearch((search) => {\n      const enabledItems = getItems().filter((item) => !item.disabled);\n      const currentItem = enabledItems.find((item) => item.value === context.value);\n      const nextItem = findNextItem(enabledItems, search, currentItem);\n      if (nextItem !== undefined) {\n        context.onValueChange(nextItem.value);\n      }\n    });\n\n    const handleOpen = (pointerEvent?: React.MouseEvent | React.PointerEvent) => {\n      if (!isDisabled) {\n        context.onOpenChange(true);\n        // reset typeahead when we open\n        resetTypeahead();\n      }\n\n      if (pointerEvent) {\n        context.triggerPointerDownPosRef.current = {\n          x: Math.round(pointerEvent.pageX),\n          y: Math.round(pointerEvent.pageY),\n        };\n      }\n    };\n\n    return (\n      <PopperPrimitive.Anchor asChild {...popperScope}>\n        <Primitive.button\n          type=\"button\"\n          role=\"combobox\"\n          aria-controls={context.contentId}\n          aria-expanded={context.open}\n          aria-required={context.required}\n          aria-autocomplete=\"none\"\n          dir={context.dir}\n          data-state={context.open ? 'open' : 'closed'}\n          disabled={isDisabled}\n          data-disabled={isDisabled ? '' : undefined}\n          data-placeholder={shouldShowPlaceholder(context.value) ? '' : undefined}\n          {...triggerProps}\n          ref={composedRefs}\n          // Enable compatibility with native label or custom `Label` \"click\" for Safari:\n          onClick={composeEventHandlers(triggerProps.onClick, (event) => {\n            // Whilst browsers generally have no issue focusing the trigger when clicking\n            // on a label, Safari seems to struggle with the fact that there's no `onClick`.\n            // We force `focus` in this case. Note: this doesn't create any other side-effect\n            // because we are preventing default in `onPointerDown` so effectively\n            // this only runs for a label \"click\"\n            event.currentTarget.focus();\n\n            // Open on click when using a touch or pen device\n            if (pointerTypeRef.current !== 'mouse') {\n              handleOpen(event);\n            }\n          })}\n          onPointerDown={composeEventHandlers(triggerProps.onPointerDown, (event) => {\n            pointerTypeRef.current = event.pointerType;\n\n            // prevent implicit pointer capture\n            // https://www.w3.org/TR/pointerevents3/#implicit-pointer-capture\n            const target = event.target as HTMLElement;\n            if (target.hasPointerCapture(event.pointerId)) {\n              target.releasePointerCapture(event.pointerId);\n            }\n\n            // only call handler if it's the left button (mousedown gets triggered by all mouse buttons)\n            // but not when the control key is pressed (avoiding MacOS right click); also not for touch\n            // devices because that would open the menu on scroll. (pen devices behave as touch on iOS).\n            if (event.button === 0 && event.ctrlKey === false && event.pointerType === 'mouse') {\n              handleOpen(event);\n              // prevent trigger from stealing focus from the active item after opening.\n              event.preventDefault();\n            }\n          })}\n          onKeyDown={composeEventHandlers(triggerProps.onKeyDown, (event) => {\n            const isTypingAhead = searchRef.current !== '';\n            const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;\n            if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);\n            if (isTypingAhead && event.key === ' ') return;\n            if (OPEN_KEYS.includes(event.key)) {\n              handleOpen();\n              event.preventDefault();\n            }\n          })}\n        />\n      </PopperPrimitive.Anchor>\n    );\n  }\n);\n\nSelectTrigger.displayName = TRIGGER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectValue\n * -----------------------------------------------------------------------------------------------*/\n\nconst VALUE_NAME = 'SelectValue';\n\ntype SelectValueElement = React.ComponentRef<typeof Primitive.span>;\ntype PrimitiveSpanProps = React.ComponentPropsWithoutRef<typeof Primitive.span>;\ninterface SelectValueProps extends Omit<PrimitiveSpanProps, 'placeholder'> {\n  placeholder?: React.ReactNode;\n}\n\nconst SelectValue = React.forwardRef<SelectValueElement, SelectValueProps>(\n  (props: ScopedProps<SelectValueProps>, forwardedRef) => {\n    // We ignore `className` and `style` as this part shouldn't be styled.\n    const { __scopeSelect, className, style, children, placeholder = '', ...valueProps } = props;\n    const context = useSelectContext(VALUE_NAME, __scopeSelect);\n    const { onValueNodeHasChildrenChange } = context;\n    const hasChildren = children !== undefined;\n    const composedRefs = useComposedRefs(forwardedRef, context.onValueNodeChange);\n\n    useLayoutEffect(() => {\n      onValueNodeHasChildrenChange(hasChildren);\n    }, [onValueNodeHasChildrenChange, hasChildren]);\n\n    return (\n      <Primitive.span\n        {...valueProps}\n        ref={composedRefs}\n        // we don't want events from the portalled `SelectValue` children to bubble\n        // through the item they came from\n        style={{ pointerEvents: 'none' }}\n      >\n        {shouldShowPlaceholder(context.value) ? <>{placeholder}</> : children}\n      </Primitive.span>\n    );\n  }\n);\n\nSelectValue.displayName = VALUE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectIcon\n * -----------------------------------------------------------------------------------------------*/\n\nconst ICON_NAME = 'SelectIcon';\n\ntype SelectIconElement = React.ComponentRef<typeof Primitive.span>;\ninterface SelectIconProps extends PrimitiveSpanProps {}\n\nconst SelectIcon = React.forwardRef<SelectIconElement, SelectIconProps>(\n  (props: ScopedProps<SelectIconProps>, forwardedRef) => {\n    const { __scopeSelect, children, ...iconProps } = props;\n    return (\n      <Primitive.span aria-hidden {...iconProps} ref={forwardedRef}>\n        {children || ''}\n      </Primitive.span>\n    );\n  }\n);\n\nSelectIcon.displayName = ICON_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectPortal\n * -----------------------------------------------------------------------------------------------*/\n\nconst PORTAL_NAME = 'SelectPortal';\n\ntype PortalProps = React.ComponentPropsWithoutRef<typeof PortalPrimitive>;\ninterface SelectPortalProps {\n  children?: React.ReactNode;\n  /**\n   * Specify a container element to portal the content into.\n   */\n  container?: PortalProps['container'];\n}\n\nconst SelectPortal: React.FC<SelectPortalProps> = (props: ScopedProps<SelectPortalProps>) => {\n  return <PortalPrimitive asChild {...props} />;\n};\n\nSelectPortal.displayName = PORTAL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectContent\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_NAME = 'SelectContent';\n\ntype SelectContentElement = SelectContentImplElement;\ninterface SelectContentProps extends SelectContentImplProps {}\n\nconst SelectContent = React.forwardRef<SelectContentElement, SelectContentProps>(\n  (props: ScopedProps<SelectContentProps>, forwardedRef) => {\n    const context = useSelectContext(CONTENT_NAME, props.__scopeSelect);\n    const [fragment, setFragment] = React.useState<DocumentFragment>();\n\n    // setting the fragment in `useLayoutEffect` as `DocumentFragment` doesn't exist on the server\n    useLayoutEffect(() => {\n      setFragment(new DocumentFragment());\n    }, []);\n\n    if (!context.open) {\n      const frag = fragment as Element | undefined;\n      return frag\n        ? ReactDOM.createPortal(\n            <SelectContentProvider scope={props.__scopeSelect}>\n              <Collection.Slot scope={props.__scopeSelect}>\n                <div>{props.children}</div>\n              </Collection.Slot>\n            </SelectContentProvider>,\n            frag\n          )\n        : null;\n    }\n\n    return <SelectContentImpl {...props} ref={forwardedRef} />;\n  }\n);\n\nSelectContent.displayName = CONTENT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectContentImpl\n * -----------------------------------------------------------------------------------------------*/\n\nconst CONTENT_MARGIN = 10;\n\ntype SelectContentContextValue = {\n  content?: SelectContentElement | null;\n  viewport?: SelectViewportElement | null;\n  onViewportChange?: (node: SelectViewportElement | null) => void;\n  itemRefCallback?: (node: SelectItemElement | null, value: string, disabled: boolean) => void;\n  selectedItem?: SelectItemElement | null;\n  onItemLeave?: () => void;\n  itemTextRefCallback?: (\n    node: SelectItemTextElement | null,\n    value: string,\n    disabled: boolean\n  ) => void;\n  focusSelectedItem?: () => void;\n  selectedItemText?: SelectItemTextElement | null;\n  position?: SelectContentProps['position'];\n  isPositioned?: boolean;\n  searchRef?: React.RefObject<string>;\n};\n\nconst [SelectContentProvider, useSelectContentContext] =\n  createSelectContext<SelectContentContextValue>(CONTENT_NAME);\n\nconst CONTENT_IMPL_NAME = 'SelectContentImpl';\n\ntype SelectContentImplElement = SelectPopperPositionElement | SelectItemAlignedPositionElement;\ntype DismissableLayerProps = React.ComponentPropsWithoutRef<typeof DismissableLayer>;\ntype FocusScopeProps = React.ComponentPropsWithoutRef<typeof FocusScope>;\n\ntype SelectPopperPrivateProps = { onPlaced?: PopperContentProps['onPlaced'] };\n\ninterface SelectContentImplProps\n  extends Omit<SelectPopperPositionProps, keyof SelectPopperPrivateProps>,\n    Omit<SelectItemAlignedPositionProps, keyof SelectPopperPrivateProps> {\n  /**\n   * Event handler called when auto-focusing on close.\n   * Can be prevented.\n   */\n  onCloseAutoFocus?: FocusScopeProps['onUnmountAutoFocus'];\n  /**\n   * Event handler called when the escape key is down.\n   * Can be prevented.\n   */\n  onEscapeKeyDown?: DismissableLayerProps['onEscapeKeyDown'];\n  /**\n   * Event handler called when the a `pointerdown` event happens outside of the `DismissableLayer`.\n   * Can be prevented.\n   */\n  onPointerDownOutside?: DismissableLayerProps['onPointerDownOutside'];\n\n  position?: 'item-aligned' | 'popper';\n}\n\nconst Slot = createSlot('SelectContent.RemoveScroll');\n\nconst SelectContentImpl = React.forwardRef<SelectContentImplElement, SelectContentImplProps>(\n  (props: ScopedProps<SelectContentImplProps>, forwardedRef) => {\n    const {\n      __scopeSelect,\n      position = 'item-aligned',\n      onCloseAutoFocus,\n      onEscapeKeyDown,\n      onPointerDownOutside,\n      //\n      // PopperContent props\n      side,\n      sideOffset,\n      align,\n      alignOffset,\n      arrowPadding,\n      collisionBoundary,\n      collisionPadding,\n      sticky,\n      hideWhenDetached,\n      avoidCollisions,\n      //\n      ...contentProps\n    } = props;\n    const context = useSelectContext(CONTENT_NAME, __scopeSelect);\n    const [content, setContent] = React.useState<SelectContentImplElement | null>(null);\n    const [viewport, setViewport] = React.useState<SelectViewportElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));\n    const [selectedItem, setSelectedItem] = React.useState<SelectItemElement | null>(null);\n    const [selectedItemText, setSelectedItemText] = React.useState<SelectItemTextElement | null>(\n      null\n    );\n    const getItems = useCollection(__scopeSelect);\n    const [isPositioned, setIsPositioned] = React.useState(false);\n    const firstValidItemFoundRef = React.useRef(false);\n\n    // aria-hide everything except the content (better supported equivalent to setting aria-modal)\n    React.useEffect(() => {\n      if (content) return hideOthers(content);\n    }, [content]);\n\n    // Make sure the whole tree has focus guards as our `Select` may be\n    // the last element in the DOM (because of the `Portal`)\n    useFocusGuards();\n\n    const focusFirst = React.useCallback(\n      (candidates: Array<HTMLElement | null>) => {\n        const [firstItem, ...restItems] = getItems().map((item) => item.ref.current);\n        const [lastItem] = restItems.slice(-1);\n\n        const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;\n        for (const candidate of candidates) {\n          // if focus is already where we want to go, we don't want to keep going through the candidates\n          if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;\n          candidate?.scrollIntoView({ block: 'nearest' });\n          // viewport might have padding so scroll to its edges when focusing first/last items.\n          if (candidate === firstItem && viewport) viewport.scrollTop = 0;\n          if (candidate === lastItem && viewport) viewport.scrollTop = viewport.scrollHeight;\n          candidate?.focus();\n          if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;\n        }\n      },\n      [getItems, viewport]\n    );\n\n    const focusSelectedItem = React.useCallback(\n      () => focusFirst([selectedItem, content]),\n      [focusFirst, selectedItem, content]\n    );\n\n    // Since this is not dependent on layout, we want to ensure this runs at the same time as\n    // other effects across components. Hence why we don't call `focusSelectedItem` inside `position`.\n    React.useEffect(() => {\n      if (isPositioned) {\n        focusSelectedItem();\n      }\n    }, [isPositioned, focusSelectedItem]);\n\n    // prevent selecting items on `pointerup` in some cases after opening from `pointerdown`\n    // and close on `pointerup` outside.\n    const { onOpenChange, triggerPointerDownPosRef } = context;\n    React.useEffect(() => {\n      if (content) {\n        let pointerMoveDelta = { x: 0, y: 0 };\n\n        const handlePointerMove = (event: PointerEvent) => {\n          pointerMoveDelta = {\n            x: Math.abs(Math.round(event.pageX) - (triggerPointerDownPosRef.current?.x ?? 0)),\n            y: Math.abs(Math.round(event.pageY) - (triggerPointerDownPosRef.current?.y ?? 0)),\n          };\n        };\n        const handlePointerUp = (event: PointerEvent) => {\n          // If the pointer hasn't moved by a certain threshold then we prevent selecting item on `pointerup`.\n          if (pointerMoveDelta.x <= 10 && pointerMoveDelta.y <= 10) {\n            event.preventDefault();\n          } else {\n            // otherwise, if the event was outside the content, close.\n            if (!content.contains(event.target as HTMLElement)) {\n              onOpenChange(false);\n            }\n          }\n          document.removeEventListener('pointermove', handlePointerMove);\n          triggerPointerDownPosRef.current = null;\n        };\n\n        if (triggerPointerDownPosRef.current !== null) {\n          document.addEventListener('pointermove', handlePointerMove);\n          document.addEventListener('pointerup', handlePointerUp, { capture: true, once: true });\n        }\n\n        return () => {\n          document.removeEventListener('pointermove', handlePointerMove);\n          document.removeEventListener('pointerup', handlePointerUp, { capture: true });\n        };\n      }\n    }, [content, onOpenChange, triggerPointerDownPosRef]);\n\n    React.useEffect(() => {\n      const close = () => onOpenChange(false);\n      window.addEventListener('blur', close);\n      window.addEventListener('resize', close);\n      return () => {\n        window.removeEventListener('blur', close);\n        window.removeEventListener('resize', close);\n      };\n    }, [onOpenChange]);\n\n    const [searchRef, handleTypeaheadSearch] = useTypeaheadSearch((search) => {\n      const enabledItems = getItems().filter((item) => !item.disabled);\n      const currentItem = enabledItems.find((item) => item.ref.current === document.activeElement);\n      const nextItem = findNextItem(enabledItems, search, currentItem);\n      if (nextItem) {\n        /**\n         * Imperative focus during keydown is risky so we prevent React's batching updates\n         * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n         */\n        setTimeout(() => (nextItem.ref.current as HTMLElement).focus());\n      }\n    });\n\n    const itemRefCallback = React.useCallback(\n      (node: SelectItemElement | null, value: string, disabled: boolean) => {\n        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;\n        const isSelectedItem = context.value !== undefined && context.value === value;\n        if (isSelectedItem || isFirstValidItem) {\n          setSelectedItem(node);\n          if (isFirstValidItem) firstValidItemFoundRef.current = true;\n        }\n      },\n      [context.value]\n    );\n    const handleItemLeave = React.useCallback(() => content?.focus(), [content]);\n    const itemTextRefCallback = React.useCallback(\n      (node: SelectItemTextElement | null, value: string, disabled: boolean) => {\n        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;\n        const isSelectedItem = context.value !== undefined && context.value === value;\n        if (isSelectedItem || isFirstValidItem) {\n          setSelectedItemText(node);\n        }\n      },\n      [context.value]\n    );\n\n    const SelectPosition = position === 'popper' ? SelectPopperPosition : SelectItemAlignedPosition;\n\n    // Silently ignore props that are not supported by `SelectItemAlignedPosition`\n    const popperContentProps =\n      SelectPosition === SelectPopperPosition\n        ? {\n            side,\n            sideOffset,\n            align,\n            alignOffset,\n            arrowPadding,\n            collisionBoundary,\n            collisionPadding,\n            sticky,\n            hideWhenDetached,\n            avoidCollisions,\n          }\n        : {};\n\n    return (\n      <SelectContentProvider\n        scope={__scopeSelect}\n        content={content}\n        viewport={viewport}\n        onViewportChange={setViewport}\n        itemRefCallback={itemRefCallback}\n        selectedItem={selectedItem}\n        onItemLeave={handleItemLeave}\n        itemTextRefCallback={itemTextRefCallback}\n        focusSelectedItem={focusSelectedItem}\n        selectedItemText={selectedItemText}\n        position={position}\n        isPositioned={isPositioned}\n        searchRef={searchRef}\n      >\n        <RemoveScroll as={Slot} allowPinchZoom>\n          <FocusScope\n            asChild\n            // we make sure we're not trapping once it's been closed\n            // (closed !== unmounted when animating out)\n            trapped={context.open}\n            onMountAutoFocus={(event) => {\n              // we prevent open autofocus because we manually focus the selected item\n              event.preventDefault();\n            }}\n            onUnmountAutoFocus={composeEventHandlers(onCloseAutoFocus, (event) => {\n              context.trigger?.focus({ preventScroll: true });\n              event.preventDefault();\n            })}\n          >\n            <DismissableLayer\n              asChild\n              disableOutsidePointerEvents\n              onEscapeKeyDown={onEscapeKeyDown}\n              onPointerDownOutside={onPointerDownOutside}\n              // When focus is trapped, a focusout event may still happen.\n              // We make sure we don't trigger our `onDismiss` in such case.\n              onFocusOutside={(event) => event.preventDefault()}\n              onDismiss={() => context.onOpenChange(false)}\n            >\n              <SelectPosition\n                role=\"listbox\"\n                id={context.contentId}\n                data-state={context.open ? 'open' : 'closed'}\n                dir={context.dir}\n                onContextMenu={(event) => event.preventDefault()}\n                {...contentProps}\n                {...popperContentProps}\n                onPlaced={() => setIsPositioned(true)}\n                ref={composedRefs}\n                style={{\n                  // flex layout so we can place the scroll buttons properly\n                  display: 'flex',\n                  flexDirection: 'column',\n                  // reset the outline by default as the content MAY get focused\n                  outline: 'none',\n                  ...contentProps.style,\n                }}\n                onKeyDown={composeEventHandlers(contentProps.onKeyDown, (event) => {\n                  const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;\n\n                  // select should not be navigated using tab key so we prevent it\n                  if (event.key === 'Tab') event.preventDefault();\n\n                  if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);\n\n                  if (['ArrowUp', 'ArrowDown', 'Home', 'End'].includes(event.key)) {\n                    const items = getItems().filter((item) => !item.disabled);\n                    let candidateNodes = items.map((item) => item.ref.current!);\n\n                    if (['ArrowUp', 'End'].includes(event.key)) {\n                      candidateNodes = candidateNodes.slice().reverse();\n                    }\n                    if (['ArrowUp', 'ArrowDown'].includes(event.key)) {\n                      const currentElement = event.target as SelectItemElement;\n                      const currentIndex = candidateNodes.indexOf(currentElement);\n                      candidateNodes = candidateNodes.slice(currentIndex + 1);\n                    }\n\n                    /**\n                     * Imperative focus during keydown is risky so we prevent React's batching updates\n                     * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n                     */\n                    setTimeout(() => focusFirst(candidateNodes));\n\n                    event.preventDefault();\n                  }\n                })}\n              />\n            </DismissableLayer>\n          </FocusScope>\n        </RemoveScroll>\n      </SelectContentProvider>\n    );\n  }\n);\n\nSelectContentImpl.displayName = CONTENT_IMPL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectItemAlignedPosition\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_ALIGNED_POSITION_NAME = 'SelectItemAlignedPosition';\n\ntype SelectItemAlignedPositionElement = React.ComponentRef<typeof Primitive.div>;\ninterface SelectItemAlignedPositionProps extends PrimitiveDivProps, SelectPopperPrivateProps {}\n\nconst SelectItemAlignedPosition = React.forwardRef<\n  SelectItemAlignedPositionElement,\n  SelectItemAlignedPositionProps\n>((props: ScopedProps<SelectItemAlignedPositionProps>, forwardedRef) => {\n  const { __scopeSelect, onPlaced, ...popperProps } = props;\n  const context = useSelectContext(CONTENT_NAME, __scopeSelect);\n  const contentContext = useSelectContentContext(CONTENT_NAME, __scopeSelect);\n  const [contentWrapper, setContentWrapper] = React.useState<HTMLDivElement | null>(null);\n  const [content, setContent] = React.useState<SelectItemAlignedPositionElement | null>(null);\n  const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));\n  const getItems = useCollection(__scopeSelect);\n  const shouldExpandOnScrollRef = React.useRef(false);\n  const shouldRepositionRef = React.useRef(true);\n\n  const { viewport, selectedItem, selectedItemText, focusSelectedItem } = contentContext;\n  const position = React.useCallback(() => {\n    if (\n      context.trigger &&\n      context.valueNode &&\n      contentWrapper &&\n      content &&\n      viewport &&\n      selectedItem &&\n      selectedItemText\n    ) {\n      const triggerRect = context.trigger.getBoundingClientRect();\n\n      // -----------------------------------------------------------------------------------------\n      //  Horizontal positioning\n      // -----------------------------------------------------------------------------------------\n      const contentRect = content.getBoundingClientRect();\n      const valueNodeRect = context.valueNode.getBoundingClientRect();\n      const itemTextRect = selectedItemText.getBoundingClientRect();\n\n      if (context.dir !== 'rtl') {\n        const itemTextOffset = itemTextRect.left - contentRect.left;\n        const left = valueNodeRect.left - itemTextOffset;\n        const leftDelta = triggerRect.left - left;\n        const minContentWidth = triggerRect.width + leftDelta;\n        const contentWidth = Math.max(minContentWidth, contentRect.width);\n        const rightEdge = window.innerWidth - CONTENT_MARGIN;\n        const clampedLeft = clamp(left, [\n          CONTENT_MARGIN,\n          // Prevents the content from going off the starting edge of the\n          // viewport. It may still go off the ending edge, but this can be\n          // controlled by the user since they may want to manage overflow in a\n          // specific way.\n          // https://github.com/radix-ui/primitives/issues/2049\n          Math.max(CONTENT_MARGIN, rightEdge - contentWidth),\n        ]);\n\n        contentWrapper.style.minWidth = minContentWidth + 'px';\n        contentWrapper.style.left = clampedLeft + 'px';\n      } else {\n        const itemTextOffset = contentRect.right - itemTextRect.right;\n        const right = window.innerWidth - valueNodeRect.right - itemTextOffset;\n        const rightDelta = window.innerWidth - triggerRect.right - right;\n        const minContentWidth = triggerRect.width + rightDelta;\n        const contentWidth = Math.max(minContentWidth, contentRect.width);\n        const leftEdge = window.innerWidth - CONTENT_MARGIN;\n        const clampedRight = clamp(right, [\n          CONTENT_MARGIN,\n          Math.max(CONTENT_MARGIN, leftEdge - contentWidth),\n        ]);\n\n        contentWrapper.style.minWidth = minContentWidth + 'px';\n        contentWrapper.style.right = clampedRight + 'px';\n      }\n\n      // -----------------------------------------------------------------------------------------\n      // Vertical positioning\n      // -----------------------------------------------------------------------------------------\n      const items = getItems();\n      const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;\n      const itemsHeight = viewport.scrollHeight;\n\n      const contentStyles = window.getComputedStyle(content);\n      const contentBorderTopWidth = parseInt(contentStyles.borderTopWidth, 10);\n      const contentPaddingTop = parseInt(contentStyles.paddingTop, 10);\n      const contentBorderBottomWidth = parseInt(contentStyles.borderBottomWidth, 10);\n      const contentPaddingBottom = parseInt(contentStyles.paddingBottom, 10);\n      const fullContentHeight = contentBorderTopWidth + contentPaddingTop + itemsHeight + contentPaddingBottom + contentBorderBottomWidth; // prettier-ignore\n      const minContentHeight = Math.min(selectedItem.offsetHeight * 5, fullContentHeight);\n\n      const viewportStyles = window.getComputedStyle(viewport);\n      const viewportPaddingTop = parseInt(viewportStyles.paddingTop, 10);\n      const viewportPaddingBottom = parseInt(viewportStyles.paddingBottom, 10);\n\n      const topEdgeToTriggerMiddle = triggerRect.top + triggerRect.height / 2 - CONTENT_MARGIN;\n      const triggerMiddleToBottomEdge = availableHeight - topEdgeToTriggerMiddle;\n\n      const selectedItemHalfHeight = selectedItem.offsetHeight / 2;\n      const itemOffsetMiddle = selectedItem.offsetTop + selectedItemHalfHeight;\n      const contentTopToItemMiddle = contentBorderTopWidth + contentPaddingTop + itemOffsetMiddle;\n      const itemMiddleToContentBottom = fullContentHeight - contentTopToItemMiddle;\n\n      const willAlignWithoutTopOverflow = contentTopToItemMiddle <= topEdgeToTriggerMiddle;\n\n      if (willAlignWithoutTopOverflow) {\n        const isLastItem =\n          items.length > 0 && selectedItem === items[items.length - 1]!.ref.current;\n        contentWrapper.style.bottom = 0 + 'px';\n        const viewportOffsetBottom =\n          content.clientHeight - viewport.offsetTop - viewport.offsetHeight;\n        const clampedTriggerMiddleToBottomEdge = Math.max(\n          triggerMiddleToBottomEdge,\n          selectedItemHalfHeight +\n            // viewport might have padding bottom, include it to avoid a scrollable viewport\n            (isLastItem ? viewportPaddingBottom : 0) +\n            viewportOffsetBottom +\n            contentBorderBottomWidth\n        );\n        const height = contentTopToItemMiddle + clampedTriggerMiddleToBottomEdge;\n        contentWrapper.style.height = height + 'px';\n      } else {\n        const isFirstItem = items.length > 0 && selectedItem === items[0]!.ref.current;\n        contentWrapper.style.top = 0 + 'px';\n        const clampedTopEdgeToTriggerMiddle = Math.max(\n          topEdgeToTriggerMiddle,\n          contentBorderTopWidth +\n            viewport.offsetTop +\n            // viewport might have padding top, include it to avoid a scrollable viewport\n            (isFirstItem ? viewportPaddingTop : 0) +\n            selectedItemHalfHeight\n        );\n        const height = clampedTopEdgeToTriggerMiddle + itemMiddleToContentBottom;\n        contentWrapper.style.height = height + 'px';\n        viewport.scrollTop = contentTopToItemMiddle - topEdgeToTriggerMiddle + viewport.offsetTop;\n      }\n\n      contentWrapper.style.margin = `${CONTENT_MARGIN}px 0`;\n      contentWrapper.style.minHeight = minContentHeight + 'px';\n      contentWrapper.style.maxHeight = availableHeight + 'px';\n      // -----------------------------------------------------------------------------------------\n\n      onPlaced?.();\n\n      // we don't want the initial scroll position adjustment to trigger \"expand on scroll\"\n      // so we explicitly turn it on only after they've registered.\n      requestAnimationFrame(() => (shouldExpandOnScrollRef.current = true));\n    }\n  }, [\n    getItems,\n    context.trigger,\n    context.valueNode,\n    contentWrapper,\n    content,\n    viewport,\n    selectedItem,\n    selectedItemText,\n    context.dir,\n    onPlaced,\n  ]);\n\n  useLayoutEffect(() => position(), [position]);\n\n  // copy z-index from content to wrapper\n  const [contentZIndex, setContentZIndex] = React.useState<string>();\n  useLayoutEffect(() => {\n    if (content) setContentZIndex(window.getComputedStyle(content).zIndex);\n  }, [content]);\n\n  // When the viewport becomes scrollable at the top, the scroll up button will mount.\n  // Because it is part of the normal flow, it will push down the viewport, thus throwing our\n  // trigger => selectedItem alignment off by the amount the viewport was pushed down.\n  // We wait for this to happen and then re-run the positining logic one more time to account for it.\n  const handleScrollButtonChange = React.useCallback(\n    (node: SelectScrollButtonImplElement | null) => {\n      if (node && shouldRepositionRef.current === true) {\n        position();\n        focusSelectedItem?.();\n        shouldRepositionRef.current = false;\n      }\n    },\n    [position, focusSelectedItem]\n  );\n\n  return (\n    <SelectViewportProvider\n      scope={__scopeSelect}\n      contentWrapper={contentWrapper}\n      shouldExpandOnScrollRef={shouldExpandOnScrollRef}\n      onScrollButtonChange={handleScrollButtonChange}\n    >\n      <div\n        ref={setContentWrapper}\n        style={{\n          display: 'flex',\n          flexDirection: 'column',\n          position: 'fixed',\n          zIndex: contentZIndex,\n        }}\n      >\n        <Primitive.div\n          {...popperProps}\n          ref={composedRefs}\n          style={{\n            // When we get the height of the content, it includes borders. If we were to set\n            // the height without having `boxSizing: 'border-box'` it would be too big.\n            boxSizing: 'border-box',\n            // We need to ensure the content doesn't get taller than the wrapper\n            maxHeight: '100%',\n            ...popperProps.style,\n          }}\n        />\n      </div>\n    </SelectViewportProvider>\n  );\n});\n\nSelectItemAlignedPosition.displayName = ITEM_ALIGNED_POSITION_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectPopperPosition\n * -----------------------------------------------------------------------------------------------*/\n\nconst POPPER_POSITION_NAME = 'SelectPopperPosition';\n\ntype SelectPopperPositionElement = React.ComponentRef<typeof PopperPrimitive.Content>;\ntype PopperContentProps = React.ComponentPropsWithoutRef<typeof PopperPrimitive.Content>;\ninterface SelectPopperPositionProps extends PopperContentProps, SelectPopperPrivateProps {}\n\nconst SelectPopperPosition = React.forwardRef<\n  SelectPopperPositionElement,\n  SelectPopperPositionProps\n>((props: ScopedProps<SelectPopperPositionProps>, forwardedRef) => {\n  const {\n    __scopeSelect,\n    align = 'start',\n    collisionPadding = CONTENT_MARGIN,\n    ...popperProps\n  } = props;\n  const popperScope = usePopperScope(__scopeSelect);\n\n  return (\n    <PopperPrimitive.Content\n      {...popperScope}\n      {...popperProps}\n      ref={forwardedRef}\n      align={align}\n      collisionPadding={collisionPadding}\n      style={{\n        // Ensure border-box for floating-ui calculations\n        boxSizing: 'border-box',\n        ...popperProps.style,\n        // re-namespace exposed content custom properties\n        ...{\n          '--radix-select-content-transform-origin': 'var(--radix-popper-transform-origin)',\n          '--radix-select-content-available-width': 'var(--radix-popper-available-width)',\n          '--radix-select-content-available-height': 'var(--radix-popper-available-height)',\n          '--radix-select-trigger-width': 'var(--radix-popper-anchor-width)',\n          '--radix-select-trigger-height': 'var(--radix-popper-anchor-height)',\n        },\n      }}\n    />\n  );\n});\n\nSelectPopperPosition.displayName = POPPER_POSITION_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectViewport\n * -----------------------------------------------------------------------------------------------*/\n\ntype SelectViewportContextValue = {\n  contentWrapper?: HTMLDivElement | null;\n  shouldExpandOnScrollRef?: React.RefObject<boolean>;\n  onScrollButtonChange?: (node: SelectScrollButtonImplElement | null) => void;\n};\n\nconst [SelectViewportProvider, useSelectViewportContext] =\n  createSelectContext<SelectViewportContextValue>(CONTENT_NAME, {});\n\nconst VIEWPORT_NAME = 'SelectViewport';\n\ntype SelectViewportElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface SelectViewportProps extends PrimitiveDivProps {\n  nonce?: string;\n}\n\nconst SelectViewport = React.forwardRef<SelectViewportElement, SelectViewportProps>(\n  (props: ScopedProps<SelectViewportProps>, forwardedRef) => {\n    const { __scopeSelect, nonce, ...viewportProps } = props;\n    const contentContext = useSelectContentContext(VIEWPORT_NAME, __scopeSelect);\n    const viewportContext = useSelectViewportContext(VIEWPORT_NAME, __scopeSelect);\n    const composedRefs = useComposedRefs(forwardedRef, contentContext.onViewportChange);\n    const prevScrollTopRef = React.useRef(0);\n    return (\n      <>\n        {/* Hide scrollbars cross-browser and enable momentum scroll for touch devices */}\n        <style\n          dangerouslySetInnerHTML={{\n            __html: `[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}`,\n          }}\n          nonce={nonce}\n        />\n        <Collection.Slot scope={__scopeSelect}>\n          <Primitive.div\n            data-radix-select-viewport=\"\"\n            role=\"presentation\"\n            {...viewportProps}\n            ref={composedRefs}\n            style={{\n              // we use position: 'relative' here on the `viewport` so that when we call\n              // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport\n              // (independent of the scrollUpButton).\n              position: 'relative',\n              flex: 1,\n              // Viewport should only be scrollable in the vertical direction.\n              // This won't work in vertical writing modes, so we'll need to\n              // revisit this if/when that is supported\n              // https://developer.chrome.com/blog/vertical-form-controls\n              overflow: 'hidden auto',\n              ...viewportProps.style,\n            }}\n            onScroll={composeEventHandlers(viewportProps.onScroll, (event) => {\n              const viewport = event.currentTarget;\n              const { contentWrapper, shouldExpandOnScrollRef } = viewportContext;\n              if (shouldExpandOnScrollRef?.current && contentWrapper) {\n                const scrolledBy = Math.abs(prevScrollTopRef.current - viewport.scrollTop);\n                if (scrolledBy > 0) {\n                  const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;\n                  const cssMinHeight = parseFloat(contentWrapper.style.minHeight);\n                  const cssHeight = parseFloat(contentWrapper.style.height);\n                  const prevHeight = Math.max(cssMinHeight, cssHeight);\n\n                  if (prevHeight < availableHeight) {\n                    const nextHeight = prevHeight + scrolledBy;\n                    const clampedNextHeight = Math.min(availableHeight, nextHeight);\n                    const heightDiff = nextHeight - clampedNextHeight;\n\n                    contentWrapper.style.height = clampedNextHeight + 'px';\n                    if (contentWrapper.style.bottom === '0px') {\n                      viewport.scrollTop = heightDiff > 0 ? heightDiff : 0;\n                      // ensure the content stays pinned to the bottom\n                      contentWrapper.style.justifyContent = 'flex-end';\n                    }\n                  }\n                }\n              }\n              prevScrollTopRef.current = viewport.scrollTop;\n            })}\n          />\n        </Collection.Slot>\n      </>\n    );\n  }\n);\n\nSelectViewport.displayName = VIEWPORT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectGroup\n * -----------------------------------------------------------------------------------------------*/\n\nconst GROUP_NAME = 'SelectGroup';\n\ntype SelectGroupContextValue = { id: string };\n\nconst [SelectGroupContextProvider, useSelectGroupContext] =\n  createSelectContext<SelectGroupContextValue>(GROUP_NAME);\n\ntype SelectGroupElement = React.ComponentRef<typeof Primitive.div>;\ninterface SelectGroupProps extends PrimitiveDivProps {}\n\nconst SelectGroup = React.forwardRef<SelectGroupElement, SelectGroupProps>(\n  (props: ScopedProps<SelectGroupProps>, forwardedRef) => {\n    const { __scopeSelect, ...groupProps } = props;\n    const groupId = useId();\n    return (\n      <SelectGroupContextProvider scope={__scopeSelect} id={groupId}>\n        <Primitive.div role=\"group\" aria-labelledby={groupId} {...groupProps} ref={forwardedRef} />\n      </SelectGroupContextProvider>\n    );\n  }\n);\n\nSelectGroup.displayName = GROUP_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectLabel\n * -----------------------------------------------------------------------------------------------*/\n\nconst LABEL_NAME = 'SelectLabel';\n\ntype SelectLabelElement = React.ComponentRef<typeof Primitive.div>;\ninterface SelectLabelProps extends PrimitiveDivProps {}\n\nconst SelectLabel = React.forwardRef<SelectLabelElement, SelectLabelProps>(\n  (props: ScopedProps<SelectLabelProps>, forwardedRef) => {\n    const { __scopeSelect, ...labelProps } = props;\n    const groupContext = useSelectGroupContext(LABEL_NAME, __scopeSelect);\n    return <Primitive.div id={groupContext.id} {...labelProps} ref={forwardedRef} />;\n  }\n);\n\nSelectLabel.displayName = LABEL_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectItem\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_NAME = 'SelectItem';\n\ntype SelectItemContextValue = {\n  value: string;\n  disabled: boolean;\n  textId: string;\n  isSelected: boolean;\n  onItemTextChange(node: SelectItemTextElement | null): void;\n};\n\nconst [SelectItemContextProvider, useSelectItemContext] =\n  createSelectContext<SelectItemContextValue>(ITEM_NAME);\n\ntype SelectItemElement = React.ComponentRef<typeof Primitive.div>;\ninterface SelectItemProps extends PrimitiveDivProps {\n  value: string;\n  disabled?: boolean;\n  textValue?: string;\n}\n\nconst SelectItem = React.forwardRef<SelectItemElement, SelectItemProps>(\n  (props: ScopedProps<SelectItemProps>, forwardedRef) => {\n    const {\n      __scopeSelect,\n      value,\n      disabled = false,\n      textValue: textValueProp,\n      ...itemProps\n    } = props;\n    const context = useSelectContext(ITEM_NAME, __scopeSelect);\n    const contentContext = useSelectContentContext(ITEM_NAME, __scopeSelect);\n    const isSelected = context.value === value;\n    const [textValue, setTextValue] = React.useState(textValueProp ?? '');\n    const [isFocused, setIsFocused] = React.useState(false);\n    const composedRefs = useComposedRefs(forwardedRef, (node) =>\n      contentContext.itemRefCallback?.(node, value, disabled)\n    );\n    const textId = useId();\n    const pointerTypeRef = React.useRef<React.PointerEvent['pointerType']>('touch');\n\n    const handleSelect = () => {\n      if (!disabled) {\n        context.onValueChange(value);\n        context.onOpenChange(false);\n      }\n    };\n\n    if (value === '') {\n      throw new Error(\n        'A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.'\n      );\n    }\n\n    return (\n      <SelectItemContextProvider\n        scope={__scopeSelect}\n        value={value}\n        disabled={disabled}\n        textId={textId}\n        isSelected={isSelected}\n        onItemTextChange={React.useCallback((node) => {\n          setTextValue((prevTextValue) => prevTextValue || (node?.textContent ?? '').trim());\n        }, [])}\n      >\n        <Collection.ItemSlot\n          scope={__scopeSelect}\n          value={value}\n          disabled={disabled}\n          textValue={textValue}\n        >\n          <Primitive.div\n            role=\"option\"\n            aria-labelledby={textId}\n            data-highlighted={isFocused ? '' : undefined}\n            // `isFocused` caveat fixes stuttering in VoiceOver\n            aria-selected={isSelected && isFocused}\n            data-state={isSelected ? 'checked' : 'unchecked'}\n            aria-disabled={disabled || undefined}\n            data-disabled={disabled ? '' : undefined}\n            tabIndex={disabled ? undefined : -1}\n            {...itemProps}\n            ref={composedRefs}\n            onFocus={composeEventHandlers(itemProps.onFocus, () => setIsFocused(true))}\n            onBlur={composeEventHandlers(itemProps.onBlur, () => setIsFocused(false))}\n            onClick={composeEventHandlers(itemProps.onClick, () => {\n              // Open on click when using a touch or pen device\n              if (pointerTypeRef.current !== 'mouse') handleSelect();\n            })}\n            onPointerUp={composeEventHandlers(itemProps.onPointerUp, () => {\n              // Using a mouse you should be able to do pointer down, move through\n              // the list, and release the pointer over the item to select it.\n              if (pointerTypeRef.current === 'mouse') handleSelect();\n            })}\n            onPointerDown={composeEventHandlers(itemProps.onPointerDown, (event) => {\n              pointerTypeRef.current = event.pointerType;\n            })}\n            onPointerMove={composeEventHandlers(itemProps.onPointerMove, (event) => {\n              // Remember pointer type when sliding over to this item from another one\n              pointerTypeRef.current = event.pointerType;\n              if (disabled) {\n                contentContext.onItemLeave?.();\n              } else if (pointerTypeRef.current === 'mouse') {\n                // even though safari doesn't support this option, it's acceptable\n                // as it only means it might scroll a few pixels when using the pointer.\n                event.currentTarget.focus({ preventScroll: true });\n              }\n            })}\n            onPointerLeave={composeEventHandlers(itemProps.onPointerLeave, (event) => {\n              if (event.currentTarget === document.activeElement) {\n                contentContext.onItemLeave?.();\n              }\n            })}\n            onKeyDown={composeEventHandlers(itemProps.onKeyDown, (event) => {\n              const isTypingAhead = contentContext.searchRef?.current !== '';\n              if (isTypingAhead && event.key === ' ') return;\n              if (SELECTION_KEYS.includes(event.key)) handleSelect();\n              // prevent page scroll if using the space key to select an item\n              if (event.key === ' ') event.preventDefault();\n            })}\n          />\n        </Collection.ItemSlot>\n      </SelectItemContextProvider>\n    );\n  }\n);\n\nSelectItem.displayName = ITEM_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectItemText\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_TEXT_NAME = 'SelectItemText';\n\ntype SelectItemTextElement = React.ComponentRef<typeof Primitive.span>;\ninterface SelectItemTextProps extends PrimitiveSpanProps {}\n\nconst SelectItemText = React.forwardRef<SelectItemTextElement, SelectItemTextProps>(\n  (props: ScopedProps<SelectItemTextProps>, forwardedRef) => {\n    // We ignore `className` and `style` as this part shouldn't be styled.\n    const { __scopeSelect, className, style, ...itemTextProps } = props;\n    const context = useSelectContext(ITEM_TEXT_NAME, __scopeSelect);\n    const contentContext = useSelectContentContext(ITEM_TEXT_NAME, __scopeSelect);\n    const itemContext = useSelectItemContext(ITEM_TEXT_NAME, __scopeSelect);\n    const nativeOptionsContext = useSelectNativeOptionsContext(ITEM_TEXT_NAME, __scopeSelect);\n    const [itemTextNode, setItemTextNode] = React.useState<SelectItemTextElement | null>(null);\n    const composedRefs = useComposedRefs(\n      forwardedRef,\n      (node) => setItemTextNode(node),\n      itemContext.onItemTextChange,\n      (node) => contentContext.itemTextRefCallback?.(node, itemContext.value, itemContext.disabled)\n    );\n\n    const textContent = itemTextNode?.textContent;\n    const nativeOption = React.useMemo(\n      () => (\n        <option key={itemContext.value} value={itemContext.value} disabled={itemContext.disabled}>\n          {textContent}\n        </option>\n      ),\n      [itemContext.disabled, itemContext.value, textContent]\n    );\n\n    const { onNativeOptionAdd, onNativeOptionRemove } = nativeOptionsContext;\n    useLayoutEffect(() => {\n      onNativeOptionAdd(nativeOption);\n      return () => onNativeOptionRemove(nativeOption);\n    }, [onNativeOptionAdd, onNativeOptionRemove, nativeOption]);\n\n    return (\n      <>\n        <Primitive.span id={itemContext.textId} {...itemTextProps} ref={composedRefs} />\n\n        {/* Portal the select item text into the trigger value node */}\n        {itemContext.isSelected && context.valueNode && !context.valueNodeHasChildren\n          ? ReactDOM.createPortal(itemTextProps.children, context.valueNode)\n          : null}\n      </>\n    );\n  }\n);\n\nSelectItemText.displayName = ITEM_TEXT_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectItemIndicator\n * -----------------------------------------------------------------------------------------------*/\n\nconst ITEM_INDICATOR_NAME = 'SelectItemIndicator';\n\ntype SelectItemIndicatorElement = React.ComponentRef<typeof Primitive.span>;\ninterface SelectItemIndicatorProps extends PrimitiveSpanProps {}\n\nconst SelectItemIndicator = React.forwardRef<SelectItemIndicatorElement, SelectItemIndicatorProps>(\n  (props: ScopedProps<SelectItemIndicatorProps>, forwardedRef) => {\n    const { __scopeSelect, ...itemIndicatorProps } = props;\n    const itemContext = useSelectItemContext(ITEM_INDICATOR_NAME, __scopeSelect);\n    return itemContext.isSelected ? (\n      <Primitive.span aria-hidden {...itemIndicatorProps} ref={forwardedRef} />\n    ) : null;\n  }\n);\n\nSelectItemIndicator.displayName = ITEM_INDICATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectScrollUpButton\n * -----------------------------------------------------------------------------------------------*/\n\nconst SCROLL_UP_BUTTON_NAME = 'SelectScrollUpButton';\n\ntype SelectScrollUpButtonElement = SelectScrollButtonImplElement;\ninterface SelectScrollUpButtonProps extends Omit<SelectScrollButtonImplProps, 'onAutoScroll'> {}\n\nconst SelectScrollUpButton = React.forwardRef<\n  SelectScrollUpButtonElement,\n  SelectScrollUpButtonProps\n>((props: ScopedProps<SelectScrollUpButtonProps>, forwardedRef) => {\n  const contentContext = useSelectContentContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);\n  const viewportContext = useSelectViewportContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);\n  const [canScrollUp, setCanScrollUp] = React.useState(false);\n  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);\n\n  useLayoutEffect(() => {\n    if (contentContext.viewport && contentContext.isPositioned) {\n      const viewport = contentContext.viewport;\n      function handleScroll() {\n        const canScrollUp = viewport.scrollTop > 0;\n        setCanScrollUp(canScrollUp);\n      }\n      handleScroll();\n      viewport.addEventListener('scroll', handleScroll);\n      return () => viewport.removeEventListener('scroll', handleScroll);\n    }\n  }, [contentContext.viewport, contentContext.isPositioned]);\n\n  return canScrollUp ? (\n    <SelectScrollButtonImpl\n      {...props}\n      ref={composedRefs}\n      onAutoScroll={() => {\n        const { viewport, selectedItem } = contentContext;\n        if (viewport && selectedItem) {\n          viewport.scrollTop = viewport.scrollTop - selectedItem.offsetHeight;\n        }\n      }}\n    />\n  ) : null;\n});\n\nSelectScrollUpButton.displayName = SCROLL_UP_BUTTON_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectScrollDownButton\n * -----------------------------------------------------------------------------------------------*/\n\nconst SCROLL_DOWN_BUTTON_NAME = 'SelectScrollDownButton';\n\ntype SelectScrollDownButtonElement = SelectScrollButtonImplElement;\ninterface SelectScrollDownButtonProps extends Omit<SelectScrollButtonImplProps, 'onAutoScroll'> {}\n\nconst SelectScrollDownButton = React.forwardRef<\n  SelectScrollDownButtonElement,\n  SelectScrollDownButtonProps\n>((props: ScopedProps<SelectScrollDownButtonProps>, forwardedRef) => {\n  const contentContext = useSelectContentContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);\n  const viewportContext = useSelectViewportContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);\n  const [canScrollDown, setCanScrollDown] = React.useState(false);\n  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);\n\n  useLayoutEffect(() => {\n    if (contentContext.viewport && contentContext.isPositioned) {\n      const viewport = contentContext.viewport;\n      function handleScroll() {\n        const maxScroll = viewport.scrollHeight - viewport.clientHeight;\n        // we use Math.ceil here because if the UI is zoomed-in\n        // `scrollTop` is not always reported as an integer\n        const canScrollDown = Math.ceil(viewport.scrollTop) < maxScroll;\n        setCanScrollDown(canScrollDown);\n      }\n      handleScroll();\n      viewport.addEventListener('scroll', handleScroll);\n      return () => viewport.removeEventListener('scroll', handleScroll);\n    }\n  }, [contentContext.viewport, contentContext.isPositioned]);\n\n  return canScrollDown ? (\n    <SelectScrollButtonImpl\n      {...props}\n      ref={composedRefs}\n      onAutoScroll={() => {\n        const { viewport, selectedItem } = contentContext;\n        if (viewport && selectedItem) {\n          viewport.scrollTop = viewport.scrollTop + selectedItem.offsetHeight;\n        }\n      }}\n    />\n  ) : null;\n});\n\nSelectScrollDownButton.displayName = SCROLL_DOWN_BUTTON_NAME;\n\ntype SelectScrollButtonImplElement = React.ComponentRef<typeof Primitive.div>;\ninterface SelectScrollButtonImplProps extends PrimitiveDivProps {\n  onAutoScroll(): void;\n}\n\nconst SelectScrollButtonImpl = React.forwardRef<\n  SelectScrollButtonImplElement,\n  SelectScrollButtonImplProps\n>((props: ScopedProps<SelectScrollButtonImplProps>, forwardedRef) => {\n  const { __scopeSelect, onAutoScroll, ...scrollIndicatorProps } = props;\n  const contentContext = useSelectContentContext('SelectScrollButton', __scopeSelect);\n  const autoScrollTimerRef = React.useRef<number | null>(null);\n  const getItems = useCollection(__scopeSelect);\n\n  const clearAutoScrollTimer = React.useCallback(() => {\n    if (autoScrollTimerRef.current !== null) {\n      window.clearInterval(autoScrollTimerRef.current);\n      autoScrollTimerRef.current = null;\n    }\n  }, []);\n\n  React.useEffect(() => {\n    return () => clearAutoScrollTimer();\n  }, [clearAutoScrollTimer]);\n\n  // When the viewport becomes scrollable on either side, the relevant scroll button will mount.\n  // Because it is part of the normal flow, it will push down (top button) or shrink (bottom button)\n  // the viewport, potentially causing the active item to now be partially out of view.\n  // We re-run the `scrollIntoView` logic to make sure it stays within the viewport.\n  useLayoutEffect(() => {\n    const activeItem = getItems().find((item) => item.ref.current === document.activeElement);\n    activeItem?.ref.current?.scrollIntoView({ block: 'nearest' });\n  }, [getItems]);\n\n  return (\n    <Primitive.div\n      aria-hidden\n      {...scrollIndicatorProps}\n      ref={forwardedRef}\n      style={{ flexShrink: 0, ...scrollIndicatorProps.style }}\n      onPointerDown={composeEventHandlers(scrollIndicatorProps.onPointerDown, () => {\n        if (autoScrollTimerRef.current === null) {\n          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);\n        }\n      })}\n      onPointerMove={composeEventHandlers(scrollIndicatorProps.onPointerMove, () => {\n        contentContext.onItemLeave?.();\n        if (autoScrollTimerRef.current === null) {\n          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);\n        }\n      })}\n      onPointerLeave={composeEventHandlers(scrollIndicatorProps.onPointerLeave, () => {\n        clearAutoScrollTimer();\n      })}\n    />\n  );\n});\n\n/* -------------------------------------------------------------------------------------------------\n * SelectSeparator\n * -----------------------------------------------------------------------------------------------*/\n\nconst SEPARATOR_NAME = 'SelectSeparator';\n\ntype SelectSeparatorElement = React.ComponentRef<typeof Primitive.div>;\ninterface SelectSeparatorProps extends PrimitiveDivProps {}\n\nconst SelectSeparator = React.forwardRef<SelectSeparatorElement, SelectSeparatorProps>(\n  (props: ScopedProps<SelectSeparatorProps>, forwardedRef) => {\n    const { __scopeSelect, ...separatorProps } = props;\n    return <Primitive.div aria-hidden {...separatorProps} ref={forwardedRef} />;\n  }\n);\n\nSelectSeparator.displayName = SEPARATOR_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectArrow\n * -----------------------------------------------------------------------------------------------*/\n\nconst ARROW_NAME = 'SelectArrow';\n\ntype SelectArrowElement = React.ComponentRef<typeof PopperPrimitive.Arrow>;\ntype PopperArrowProps = React.ComponentPropsWithoutRef<typeof PopperPrimitive.Arrow>;\ninterface SelectArrowProps extends PopperArrowProps {}\n\nconst SelectArrow = React.forwardRef<SelectArrowElement, SelectArrowProps>(\n  (props: ScopedProps<SelectArrowProps>, forwardedRef) => {\n    const { __scopeSelect, ...arrowProps } = props;\n    const popperScope = usePopperScope(__scopeSelect);\n    const context = useSelectContext(ARROW_NAME, __scopeSelect);\n    const contentContext = useSelectContentContext(ARROW_NAME, __scopeSelect);\n    return context.open && contentContext.position === 'popper' ? (\n      <PopperPrimitive.Arrow {...popperScope} {...arrowProps} ref={forwardedRef} />\n    ) : null;\n  }\n);\n\nSelectArrow.displayName = ARROW_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * SelectBubbleInput\n * -----------------------------------------------------------------------------------------------*/\n\nconst BUBBLE_INPUT_NAME = 'SelectBubbleInput';\n\ntype InputProps = React.ComponentPropsWithoutRef<typeof Primitive.select>;\ninterface SwitchBubbleInputProps extends InputProps {}\n\nconst SelectBubbleInput = React.forwardRef<HTMLSelectElement, SwitchBubbleInputProps>(\n  ({ __scopeSelect, value, ...props }: ScopedProps<SwitchBubbleInputProps>, forwardedRef) => {\n    const ref = React.useRef<HTMLSelectElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref);\n    const prevValue = usePrevious(value);\n\n    // Bubble value change to parents (e.g form change event)\n    React.useEffect(() => {\n      const select = ref.current;\n      if (!select) return;\n\n      const selectProto = window.HTMLSelectElement.prototype;\n      const descriptor = Object.getOwnPropertyDescriptor(\n        selectProto,\n        'value'\n      ) as PropertyDescriptor;\n      const setValue = descriptor.set;\n      if (prevValue !== value && setValue) {\n        const event = new Event('change', { bubbles: true });\n        setValue.call(select, value);\n        select.dispatchEvent(event);\n      }\n    }, [prevValue, value]);\n\n    /**\n     * We purposefully use a `select` here to support form autofill as much as\n     * possible.\n     *\n     * We purposefully do not add the `value` attribute here to allow the value\n     * to be set programmatically and bubble to any parent form `onChange`\n     * event. Adding the `value` will cause React to consider the programmatic\n     * dispatch a duplicate and it will get swallowed.\n     *\n     * We use visually hidden styles rather than `display: \"none\"` because\n     * Safari autofill won't work otherwise.\n     */\n    return (\n      <Primitive.select\n        {...props}\n        style={{ ...VISUALLY_HIDDEN_STYLES, ...props.style }}\n        ref={composedRefs}\n        defaultValue={value}\n      />\n    );\n  }\n);\n\nSelectBubbleInput.displayName = BUBBLE_INPUT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction shouldShowPlaceholder(value?: string) {\n  return value === '' || value === undefined;\n}\n\nfunction useTypeaheadSearch(onSearchChange: (search: string) => void) {\n  const handleSearchChange = useCallbackRef(onSearchChange);\n  const searchRef = React.useRef('');\n  const timerRef = React.useRef(0);\n\n  const handleTypeaheadSearch = React.useCallback(\n    (key: string) => {\n      const search = searchRef.current + key;\n      handleSearchChange(search);\n\n      (function updateSearch(value: string) {\n        searchRef.current = value;\n        window.clearTimeout(timerRef.current);\n        // Reset `searchRef` 1 second after it was last updated\n        if (value !== '') timerRef.current = window.setTimeout(() => updateSearch(''), 1000);\n      })(search);\n    },\n    [handleSearchChange]\n  );\n\n  const resetTypeahead = React.useCallback(() => {\n    searchRef.current = '';\n    window.clearTimeout(timerRef.current);\n  }, []);\n\n  React.useEffect(() => {\n    return () => window.clearTimeout(timerRef.current);\n  }, []);\n\n  return [searchRef, handleTypeaheadSearch, resetTypeahead] as const;\n}\n\n/**\n * This is the \"meat\" of the typeahead matching logic. It takes in a list of items,\n * the search and the current item, and returns the next item (or `undefined`).\n *\n * We normalize the search because if a user has repeatedly pressed a character,\n * we want the exact same behavior as if we only had that one character\n * (ie. cycle through items starting with that character)\n *\n * We also reorder the items by wrapping the array around the current item.\n * This is so we always look forward from the current item, and picking the first\n * item will always be the correct one.\n *\n * Finally, if the normalized search is exactly one character, we exclude the\n * current item from the values because otherwise it would be the first to match always\n * and focus would never move. This is as opposed to the regular case, where we\n * don't want focus to move if the current item still matches.\n */\nfunction findNextItem<T extends { textValue: string }>(\n  items: T[],\n  search: string,\n  currentItem?: T\n) {\n  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);\n  const normalizedSearch = isRepeated ? search[0]! : search;\n  const currentItemIndex = currentItem ? items.indexOf(currentItem) : -1;\n  let wrappedItems = wrapArray(items, Math.max(currentItemIndex, 0));\n  const excludeCurrentItem = normalizedSearch.length === 1;\n  if (excludeCurrentItem) wrappedItems = wrappedItems.filter((v) => v !== currentItem);\n  const nextItem = wrappedItems.find((item) =>\n    item.textValue.toLowerCase().startsWith(normalizedSearch.toLowerCase())\n  );\n  return nextItem !== currentItem ? nextItem : undefined;\n}\n\n/**\n * Wraps an array around itself at a given start index\n * Example: `wrapArray(['a', 'b', 'c', 'd'], 2) === ['c', 'd', 'a', 'b']`\n */\nfunction wrapArray<T>(array: T[], startIndex: number) {\n  return array.map<T>((_, index) => array[(startIndex + index) % array.length]!);\n}\n\nconst Root = Select;\nconst Trigger = SelectTrigger;\nconst Value = SelectValue;\nconst Icon = SelectIcon;\nconst Portal = SelectPortal;\nconst Content = SelectContent;\nconst Viewport = SelectViewport;\nconst Group = SelectGroup;\nconst Label = SelectLabel;\nconst Item = SelectItem;\nconst ItemText = SelectItemText;\nconst ItemIndicator = SelectItemIndicator;\nconst ScrollUpButton = SelectScrollUpButton;\nconst ScrollDownButton = SelectScrollDownButton;\nconst Separator = SelectSeparator;\nconst Arrow = SelectArrow;\n\nexport {\n  createSelectScope,\n  //\n  Select,\n  SelectTrigger,\n  SelectValue,\n  SelectIcon,\n  SelectPortal,\n  SelectContent,\n  SelectViewport,\n  SelectGroup,\n  SelectLabel,\n  SelectItem,\n  SelectItemText,\n  SelectItemIndicator,\n  SelectScrollUpButton,\n  SelectScrollDownButton,\n  SelectSeparator,\n  SelectArrow,\n  //\n  Root,\n  Trigger,\n  Value,\n  Icon,\n  Portal,\n  Content,\n  Viewport,\n  Group,\n  Label,\n  Item,\n  ItemText,\n  ItemIndicator,\n  ScrollUpButton,\n  ScrollDownButton,\n  Separator,\n  Arrow,\n};\nexport type {\n  SelectProps,\n  SelectTriggerProps,\n  SelectValueProps,\n  SelectIconProps,\n  SelectPortalProps,\n  SelectContentProps,\n  SelectViewportProps,\n  SelectGroupProps,\n  SelectLabelProps,\n  SelectItemProps,\n  SelectItemTextProps,\n  SelectItemIndicatorProps,\n  SelectScrollUpButtonProps,\n  SelectScrollDownButtonProps,\n  SelectSeparatorProps,\n  SelectArrowProps,\n};\n","import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [['path', { d: 'm18 15-6-6-6 6', key: '153udz' }]];\n\n/**\n * @component @name ChevronUp\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJtMTggMTUtNi02LTYgNiIgLz4KPC9zdmc+Cg==) - https://lucide.dev/icons/chevron-up\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst ChevronUp = createLucideIcon('chevron-up', __iconNode);\n\nexport default ChevronUp;\n","// packages/react/direction/src/direction.tsx\nimport * as React from \"react\";\nimport { jsx } from \"react/jsx-runtime\";\nvar DirectionContext = React.createContext(void 0);\nvar DirectionProvider = (props) => {\n  const { dir, children } = props;\n  return /* @__PURE__ */ jsx(DirectionContext.Provider, { value: dir, children });\n};\nfunction useDirection(localDir) {\n  const globalDir = React.useContext(DirectionContext);\n  return localDir || globalDir || \"ltr\";\n}\nvar Provider = DirectionProvider;\nexport {\n  DirectionProvider,\n  Provider,\n  useDirection\n};\n//# sourceMappingURL=index.mjs.map\n","import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [['path', { d: 'M20 6 9 17l-5-5', key: '1gmf2c' }]];\n\n/**\n * @component @name Check\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMjAgNiA5IDE3bC01LTUiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/check\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst Check = createLucideIcon('check', __iconNode);\n\nexport default Check;\n","import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [['path', { d: 'm6 9 6 6 6-6', key: 'qrunsl' }]];\n\n/**\n * @component @name ChevronDown\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJtNiA5IDYgNiA2LTYiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/chevron-down\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst ChevronDown = createLucideIcon('chevron-down', __iconNode);\n\nexport default ChevronDown;\n"],"names":["PopperArrow","Root","handleScroll","canScrollUp","canScrollDown","Content"],"sourceRoot":"","ignoreList":[0,1,2,3,4,5,6,8,9,12]}