{"version":3,"file":"static/chunks/258-716b0e14a6c40595.js","mappings":"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C,CACA,QACI,IAAa,YACjB,0BACA,cACA,CAAO,CACP,CAAK,CACL,CACA,OACA,qBACA,CACA,SACA,4BAEA,QACA,OAA+B,eAC/B,0BACA,GAAiB,QAAU,MAE3B,CACA,YAAsB,EACtB,oBACA,2CAAuE,QAAU,QACjF,CACA,UACI,IAAa,YACjB,2BACA,IACA,CAAO,CACP,CAAK,CACL,CACA,UACI,IAAa,YACjB,0BACA,WACA,CAAO,CACP,CAAK,CACL,CACA,WACI,IAAa,YACjB,0BACA,YACA,CAAO,CACP,CAAK,CACL,CACA,YCvFA,gBAAkC,GAAY,CAC9C,gBAAyB,EACzB,QACA,cACA,gBACA,gBACA,SACA,CACA,IACA,GACA,EACA,aACA,UAAyB,GAAQ,EACjC,mBACA,qBACA,oCACA,OACA,CAAK,EAEL,OADA,YACA,CACA,CACA,OACA,eACA,WACA,uBACA,qBACA,EACA,UAEA,kBAEA,CACA,aAAkB,wBAAyB,CAC3C,CACA,UACA,sBACA,WACA,uBACA,qBACA,MACA,eACA,kBACA,SACA,aAEA,EAAY,cACZ,kBAGA,CACA,CACA,aAAkB,0BAA2B,CAC7C,CACA,UACA,WACA,sBAOA,QAPA,EACA,qBACA,UACA,+BAEA,eACA,CAGA,CACA,WACA,WACA,sBAIA,wBAJA,EACA,uDACA,uCACA,CAGA,CAHM,OAIN,CACI,IAAa,YACjB,oBACA,aAAsB,0BAA2B,CACjD,CAAO,EACP,gBACA,eACA,CAAK,CACL,CACA,SACA,0BACA,CACA,QACA,OAA+B,eAC/B,0BACA,GAAoB,QAAa,MAEjC,CACA,YAAsB,EACtB,+BAA8C,QAAa,MAC3D,CACA,UACI,IAAa,YACjB,2BACA,IACA,CAAO,CACP,CAAK,CACL,CACA,wBACA,gDACA,OAAW,IAAa,OACxB,gBACA,4BAAoE,IAAI,IAGxE,CACA,EACA,cACA,0BACA,yBCpHA,cACA,OACA,gBACA,gBACA,6CACA,0BACA,+BACA,GAAqB,wBACrB,IACA,YACA,SACA,MACA,kCACA,cACA,SACA,iBACA,KAEA,uCACA,IACA,CAAiB,EAEjB,SAEA,CAAW,CACX,EACA,EAAwB,QAAa,2BACrC,iBACA,KACA,wBAEA,2BACA,0BAaA,OAXA,KACA,OACA,gBACA,oBACA,YACA,iCACA,qBAGA,OADA,KACA,CACA,KAEA,aACA,UAAkB,GAAW,UAC7B,IAAmC,IAAU,CAAG,IAAQ,CACxD,OACA,qBACA,8BACA,CACA,EACA,gBACA,qBAEA,GACA,QACA,YACA,EACA,GALA,EAgDA,kBAAyC,eAAmB,EAC5D,gEACA,EAlDA,GAKA,KACA,gBACA,EAAU,IACV,kBACA,GACA,4CACA,gBACA,MAEA,eACA,GACA,EAAY,SACZ,CACA,QACA,CACA,qBACA,cACA,sBACA,EACA,CACA,gBACA,oBACA,oBACA,gBACa,CACb,GAIA,WAEA,CACA,CACA,CACA,oBAAqC,eAAmB,EACxD,iBACA,qCACA,KACA,EACA,KACA,GACA,MACA,CCzFA,YACA,IACA,GACA,GACA,GACA,GACA,GACA,GACA,cACA,IAAyB,EACzB,0BAAgD,EAChD,6BAAsD,EACtD,WADmE,aACnE,KACA,gBACA,gBACA,SACA,CACA,QACA,UACA,cACA,QAA6B,GAAY,qBACzC,IACA,mCACA,kBAEA,CAAK,EACL,QAA8B,GAAa,qBAC3C,IACA,mCACA,mBAEA,CAAK,EACL,CACA,UACA,UACA,cACA,YACA,eACA,YACA,eACA,CACA,cACA,wBAAsC,4BAAqC,SAE3E,cACA,wBAAyC,sBAA+B,QACxE,CAQA,gBACA,yCAA+C,EAAU,EACzD,2CACA,CACA,mBACA,kCACA,wBACA,sBACA,WACA,oBAEA,qCAAyD,QAAgB,kBACzE,sBAEA,mBACA,CACA,kBACA,yCAAoD,UAAiB,GAErE,GADA,OACA,CAEA,CACA,oBACA,yCAAwD,EAAU,EAClE,cACA,aAEA,gBACA,EAAiB,QAAgB,MACjC,cAGA,wCAA0E,eAA0B,CACpG,CACA,sBACA,OAAW,IAAa,OACxB,sCAAqD,EAAU,IAC/D,EACA,yBACA,EAEA,CACA,iBACA,yCAA+C,EAAU,EACzD,mBACA,cACA,KACA,CACA,iBACA,cACI,IAAa,YACjB,yBACA,WACA,CAAO,CACP,CAAK,CACL,CACA,kBACA,cACA,OAAW,IAAa,YACxB,yBACA,SACA,CAAO,EACP,oBACA,CACA,cACA,IACA,CAAS,CACT,IAGA,CACA,oBAA2C,EAC3C,OAAqC,gBAIrC,mBAHqB,IAAa,OAClC,6CAEA,KAAsC,IAAI,QAAQ,IAAI,CACtD,CACA,wBAAyC,EACzC,OAAW,IAAa,WAIxB,CAHA,+BACA,cACA,CAAO,EACP,yBACA,kBAEA,oBACA,CACA,KACA,sCACA,CAAS,CACT,GAGA,CACA,qBAAsC,EACtC,OACA,KACA,iCACA,EAUA,mBATqB,IAAa,OAClC,yEACA,wBAIA,OAHA,gBACA,WAAkC,KAAI,EAEtC,kDACA,CAAO,IAEP,KAAsC,IAAI,CAC1C,CACA,cACA,iCACA,mBACA,aAEA,4BACA,uBACM,QAAgB,iBACtB,wCACA,CACA,iBACA,+BAAyC,IAAI,QAAQ,IAAI,CACzD,CACA,sBAEA,OADA,WAAuB,EAAqB,SAC5C,UAD4C,KAC5C,GACA,CACA,yBACA,uCAAiD,IAAI,QAAQ,IAAI,CACjE,CACA,2BAEA,OADA,WAAuB,EAAqB,SAC5C,UAD4C,UAC5C,GACA,CACA,+BACA,EAAQ,CAAa,YACrB,gCAEA,iBACA,CACA,gBACA,eAEA,mBACA,eAEA,oBACA,eAEA,qBACA,SACA,CACA,sBACA,YAA4B,QAAO,KACnC,WACA,gBACA,CAAK,CACL,CACA,oBACA,4BACA,KAMA,OALA,cACU,QAAe,gBACzB,iCAEA,CAAK,EACL,CACA,CACA,yBACA,YAA+B,QAAO,KACtC,cACA,gBACA,CAAK,CACL,CACA,uBACA,4BACA,KAMA,OALA,cACU,QAAe,mBACzB,iCAEA,CAAK,EACL,CACA,CACA,uBACA,gBACA,SAEA,OACA,mBACA,qCACA,KACA,aACA,EAmBA,OAlBA,aACA,aAAmC,QAAqB,CACxD,WACA,EACA,EAEA,+BACA,gDAEA,yBACA,8BAEA,6BACA,+BAEA,YAAqC,IAAS,EAC9C,eAEA,CACA,CACA,iCACA,cACA,EAEA,CACA,qBACA,2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","sources":["webpack://_N_E/../src/toast.tsx","webpack://_N_E/../../src/index.ts","webpack://_N_E/./node_modules/.pnpm/@tanstack+query-core@5.80.7/node_modules/@tanstack/query-core/build/modern/queryCache.js","webpack://_N_E/./node_modules/.pnpm/@tanstack+query-core@5.80.7/node_modules/@tanstack/query-core/build/modern/mutationCache.js","webpack://_N_E/./node_modules/.pnpm/@tanstack+query-core@5.80.7/node_modules/@tanstack/query-core/build/modern/infiniteQueryBehavior.js","webpack://_N_E/./node_modules/.pnpm/@tanstack+query-core@5.80.7/node_modules/@tanstack/query-core/build/modern/queryClient.js","webpack://_N_E/./node_modules/.pnpm/next@15.2.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/font/local/target.css","webpack://_N_E/../../../src/icons/x.ts","webpack://_N_E/../src/presence.tsx","webpack://_N_E/../src/use-state-machine.tsx","webpack://_N_E/./node_modules/.pnpm/next@15.2.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/api/navigation.js","webpack://_N_E/./node_modules/.pnpm/next@15.2.4_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/font/local/target.css?95a3"],"sourcesContent":["import * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { composeEventHandlers } from '@radix-ui/primitive';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { createCollection } from '@radix-ui/react-collection';\nimport { createContextScope } from '@radix-ui/react-context';\nimport * as DismissableLayer from '@radix-ui/react-dismissable-layer';\nimport { Portal } from '@radix-ui/react-portal';\nimport { Presence } from '@radix-ui/react-presence';\nimport { Primitive, dispatchDiscreteCustomEvent } from '@radix-ui/react-primitive';\nimport { useCallbackRef } from '@radix-ui/react-use-callback-ref';\nimport { useControllableState } from '@radix-ui/react-use-controllable-state';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { VisuallyHidden } from '@radix-ui/react-visually-hidden';\n\nimport type { Scope } from '@radix-ui/react-context';\n\n/* -------------------------------------------------------------------------------------------------\n * ToastProvider\n * -----------------------------------------------------------------------------------------------*/\n\nconst PROVIDER_NAME = 'ToastProvider';\n\nconst [Collection, useCollection, createCollectionScope] = createCollection<ToastElement>('Toast');\n\ntype SwipeDirection = 'up' | 'down' | 'left' | 'right';\ntype ToastProviderContextValue = {\n  label: string;\n  duration: number;\n  swipeDirection: SwipeDirection;\n  swipeThreshold: number;\n  toastCount: number;\n  viewport: ToastViewportElement | null;\n  onViewportChange(viewport: ToastViewportElement): void;\n  onToastAdd(): void;\n  onToastRemove(): void;\n  isFocusedToastEscapeKeyDownRef: React.MutableRefObject<boolean>;\n  isClosePausedRef: React.MutableRefObject<boolean>;\n};\n\ntype ScopedProps<P> = P & { __scopeToast?: Scope };\nconst [createToastContext, createToastScope] = createContextScope('Toast', [createCollectionScope]);\nconst [ToastProviderProvider, useToastProviderContext] =\n  createToastContext<ToastProviderContextValue>(PROVIDER_NAME);\n\ninterface ToastProviderProps {\n  children?: React.ReactNode;\n  /**\n   * An author-localized label for each toast. Used to help screen reader users\n   * associate the interruption with a toast.\n   * @defaultValue 'Notification'\n   */\n  label?: string;\n  /**\n   * Time in milliseconds that each toast should remain visible for.\n   * @defaultValue 5000\n   */\n  duration?: number;\n  /**\n   * Direction of pointer swipe that should close the toast.\n   * @defaultValue 'right'\n   */\n  swipeDirection?: SwipeDirection;\n  /**\n   * Distance in pixels that the swipe must pass before a close is triggered.\n   * @defaultValue 50\n   */\n  swipeThreshold?: number;\n}\n\nconst ToastProvider: React.FC<ToastProviderProps> = (props: ScopedProps<ToastProviderProps>) => {\n  const {\n    __scopeToast,\n    label = 'Notification',\n    duration = 5000,\n    swipeDirection = 'right',\n    swipeThreshold = 50,\n    children,\n  } = props;\n  const [viewport, setViewport] = React.useState<ToastViewportElement | null>(null);\n  const [toastCount, setToastCount] = React.useState(0);\n  const isFocusedToastEscapeKeyDownRef = React.useRef(false);\n  const isClosePausedRef = React.useRef(false);\n\n  if (!label.trim()) {\n    console.error(\n      `Invalid prop \\`label\\` supplied to \\`${PROVIDER_NAME}\\`. Expected non-empty \\`string\\`.`\n    );\n  }\n\n  return (\n    <Collection.Provider scope={__scopeToast}>\n      <ToastProviderProvider\n        scope={__scopeToast}\n        label={label}\n        duration={duration}\n        swipeDirection={swipeDirection}\n        swipeThreshold={swipeThreshold}\n        toastCount={toastCount}\n        viewport={viewport}\n        onViewportChange={setViewport}\n        onToastAdd={React.useCallback(() => setToastCount((prevCount) => prevCount + 1), [])}\n        onToastRemove={React.useCallback(() => setToastCount((prevCount) => prevCount - 1), [])}\n        isFocusedToastEscapeKeyDownRef={isFocusedToastEscapeKeyDownRef}\n        isClosePausedRef={isClosePausedRef}\n      >\n        {children}\n      </ToastProviderProvider>\n    </Collection.Provider>\n  );\n};\n\nToastProvider.displayName = PROVIDER_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastViewport\n * -----------------------------------------------------------------------------------------------*/\n\nconst VIEWPORT_NAME = 'ToastViewport';\nconst VIEWPORT_DEFAULT_HOTKEY = ['F8'];\nconst VIEWPORT_PAUSE = 'toast.viewportPause';\nconst VIEWPORT_RESUME = 'toast.viewportResume';\n\ntype ToastViewportElement = React.ComponentRef<typeof Primitive.ol>;\ntype PrimitiveOrderedListProps = React.ComponentPropsWithoutRef<typeof Primitive.ol>;\ninterface ToastViewportProps extends PrimitiveOrderedListProps {\n  /**\n   * The keys to use as the keyboard shortcut that will move focus to the toast viewport.\n   * @defaultValue ['F8']\n   */\n  hotkey?: string[];\n  /**\n   * An author-localized label for the toast viewport to provide context for screen reader users\n   * when navigating page landmarks. The available `{hotkey}` placeholder will be replaced for you.\n   * @defaultValue 'Notifications ({hotkey})'\n   */\n  label?: string;\n}\n\nconst ToastViewport = React.forwardRef<ToastViewportElement, ToastViewportProps>(\n  (props: ScopedProps<ToastViewportProps>, forwardedRef) => {\n    const {\n      __scopeToast,\n      hotkey = VIEWPORT_DEFAULT_HOTKEY,\n      label = 'Notifications ({hotkey})',\n      ...viewportProps\n    } = props;\n    const context = useToastProviderContext(VIEWPORT_NAME, __scopeToast);\n    const getItems = useCollection(__scopeToast);\n    const wrapperRef = React.useRef<HTMLDivElement>(null);\n    const headFocusProxyRef = React.useRef<FocusProxyElement>(null);\n    const tailFocusProxyRef = React.useRef<FocusProxyElement>(null);\n    const ref = React.useRef<ToastViewportElement>(null);\n    const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);\n    const hotkeyLabel = hotkey.join('+').replace(/Key/g, '').replace(/Digit/g, '');\n    const hasToasts = context.toastCount > 0;\n\n    React.useEffect(() => {\n      const handleKeyDown = (event: KeyboardEvent) => {\n        // we use `event.code` as it is consistent regardless of meta keys that were pressed.\n        // for example, `event.key` for `Control+Alt+t` is `†` and `t !== †`\n        const isHotkeyPressed =\n          hotkey.length !== 0 && hotkey.every((key) => (event as any)[key] || event.code === key);\n        if (isHotkeyPressed) ref.current?.focus();\n      };\n      document.addEventListener('keydown', handleKeyDown);\n      return () => document.removeEventListener('keydown', handleKeyDown);\n    }, [hotkey]);\n\n    React.useEffect(() => {\n      const wrapper = wrapperRef.current;\n      const viewport = ref.current;\n      if (hasToasts && wrapper && viewport) {\n        const handlePause = () => {\n          if (!context.isClosePausedRef.current) {\n            const pauseEvent = new CustomEvent(VIEWPORT_PAUSE);\n            viewport.dispatchEvent(pauseEvent);\n            context.isClosePausedRef.current = true;\n          }\n        };\n\n        const handleResume = () => {\n          if (context.isClosePausedRef.current) {\n            const resumeEvent = new CustomEvent(VIEWPORT_RESUME);\n            viewport.dispatchEvent(resumeEvent);\n            context.isClosePausedRef.current = false;\n          }\n        };\n\n        const handleFocusOutResume = (event: FocusEvent) => {\n          const isFocusMovingOutside = !wrapper.contains(event.relatedTarget as HTMLElement);\n          if (isFocusMovingOutside) handleResume();\n        };\n\n        const handlePointerLeaveResume = () => {\n          const isFocusInside = wrapper.contains(document.activeElement);\n          if (!isFocusInside) handleResume();\n        };\n\n        // Toasts are not in the viewport React tree so we need to bind DOM events\n        wrapper.addEventListener('focusin', handlePause);\n        wrapper.addEventListener('focusout', handleFocusOutResume);\n        wrapper.addEventListener('pointermove', handlePause);\n        wrapper.addEventListener('pointerleave', handlePointerLeaveResume);\n        window.addEventListener('blur', handlePause);\n        window.addEventListener('focus', handleResume);\n        return () => {\n          wrapper.removeEventListener('focusin', handlePause);\n          wrapper.removeEventListener('focusout', handleFocusOutResume);\n          wrapper.removeEventListener('pointermove', handlePause);\n          wrapper.removeEventListener('pointerleave', handlePointerLeaveResume);\n          window.removeEventListener('blur', handlePause);\n          window.removeEventListener('focus', handleResume);\n        };\n      }\n    }, [hasToasts, context.isClosePausedRef]);\n\n    const getSortedTabbableCandidates = React.useCallback(\n      ({ tabbingDirection }: { tabbingDirection: 'forwards' | 'backwards' }) => {\n        const toastItems = getItems();\n        const tabbableCandidates = toastItems.map((toastItem) => {\n          const toastNode = toastItem.ref.current!;\n          const toastTabbableCandidates = [toastNode, ...getTabbableCandidates(toastNode)];\n          return tabbingDirection === 'forwards'\n            ? toastTabbableCandidates\n            : toastTabbableCandidates.reverse();\n        });\n        return (\n          tabbingDirection === 'forwards' ? tabbableCandidates.reverse() : tabbableCandidates\n        ).flat();\n      },\n      [getItems]\n    );\n\n    React.useEffect(() => {\n      const viewport = ref.current;\n      // We programmatically manage tabbing as we are unable to influence\n      // the source order with portals, this allows us to reverse the\n      // tab order so that it runs from most recent toast to least\n      if (viewport) {\n        const handleKeyDown = (event: KeyboardEvent) => {\n          const isMetaKey = event.altKey || event.ctrlKey || event.metaKey;\n          const isTabKey = event.key === 'Tab' && !isMetaKey;\n\n          if (isTabKey) {\n            const focusedElement = document.activeElement;\n            const isTabbingBackwards = event.shiftKey;\n            const targetIsViewport = event.target === viewport;\n\n            // If we're back tabbing after jumping to the viewport then we simply\n            // proxy focus out to the preceding document\n            if (targetIsViewport && isTabbingBackwards) {\n              headFocusProxyRef.current?.focus();\n              return;\n            }\n\n            const tabbingDirection = isTabbingBackwards ? 'backwards' : 'forwards';\n            const sortedCandidates = getSortedTabbableCandidates({ tabbingDirection });\n            const index = sortedCandidates.findIndex((candidate) => candidate === focusedElement);\n            if (focusFirst(sortedCandidates.slice(index + 1))) {\n              event.preventDefault();\n            } else {\n              // If we can't focus that means we're at the edges so we\n              // proxy to the corresponding exit point and let the browser handle\n              // tab/shift+tab keypress and implicitly pass focus to the next valid element in the document\n              isTabbingBackwards\n                ? headFocusProxyRef.current?.focus()\n                : tailFocusProxyRef.current?.focus();\n            }\n          }\n        };\n\n        // Toasts are not in the viewport React tree so we need to bind DOM events\n        viewport.addEventListener('keydown', handleKeyDown);\n        return () => viewport.removeEventListener('keydown', handleKeyDown);\n      }\n    }, [getItems, getSortedTabbableCandidates]);\n\n    return (\n      <DismissableLayer.Branch\n        ref={wrapperRef}\n        role=\"region\"\n        aria-label={label.replace('{hotkey}', hotkeyLabel)}\n        // Ensure virtual cursor from landmarks menus triggers focus/blur for pause/resume\n        tabIndex={-1}\n        // incase list has size when empty (e.g. padding), we remove pointer events so\n        // it doesn't prevent interactions with page elements that it overlays\n        style={{ pointerEvents: hasToasts ? undefined : 'none' }}\n      >\n        {hasToasts && (\n          <FocusProxy\n            ref={headFocusProxyRef}\n            onFocusFromOutsideViewport={() => {\n              const tabbableCandidates = getSortedTabbableCandidates({\n                tabbingDirection: 'forwards',\n              });\n              focusFirst(tabbableCandidates);\n            }}\n          />\n        )}\n        {/**\n         * tabindex on the the list so that it can be focused when items are removed. we focus\n         * the list instead of the viewport so it announces number of items remaining.\n         */}\n        <Collection.Slot scope={__scopeToast}>\n          <Primitive.ol tabIndex={-1} {...viewportProps} ref={composedRefs} />\n        </Collection.Slot>\n        {hasToasts && (\n          <FocusProxy\n            ref={tailFocusProxyRef}\n            onFocusFromOutsideViewport={() => {\n              const tabbableCandidates = getSortedTabbableCandidates({\n                tabbingDirection: 'backwards',\n              });\n              focusFirst(tabbableCandidates);\n            }}\n          />\n        )}\n      </DismissableLayer.Branch>\n    );\n  }\n);\n\nToastViewport.displayName = VIEWPORT_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\nconst FOCUS_PROXY_NAME = 'ToastFocusProxy';\n\ntype FocusProxyElement = React.ComponentRef<typeof VisuallyHidden>;\ntype VisuallyHiddenProps = React.ComponentPropsWithoutRef<typeof VisuallyHidden>;\ninterface FocusProxyProps extends VisuallyHiddenProps {\n  onFocusFromOutsideViewport(): void;\n}\n\nconst FocusProxy = React.forwardRef<FocusProxyElement, ScopedProps<FocusProxyProps>>(\n  (props, forwardedRef) => {\n    const { __scopeToast, onFocusFromOutsideViewport, ...proxyProps } = props;\n    const context = useToastProviderContext(FOCUS_PROXY_NAME, __scopeToast);\n\n    return (\n      <VisuallyHidden\n        aria-hidden\n        tabIndex={0}\n        {...proxyProps}\n        ref={forwardedRef}\n        // Avoid page scrolling when focus is on the focus proxy\n        style={{ position: 'fixed' }}\n        onFocus={(event) => {\n          const prevFocusedElement = event.relatedTarget as HTMLElement | null;\n          const isFocusFromOutsideViewport = !context.viewport?.contains(prevFocusedElement);\n          if (isFocusFromOutsideViewport) onFocusFromOutsideViewport();\n        }}\n      />\n    );\n  }\n);\n\nFocusProxy.displayName = FOCUS_PROXY_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * Toast\n * -----------------------------------------------------------------------------------------------*/\n\nconst TOAST_NAME = 'Toast';\nconst TOAST_SWIPE_START = 'toast.swipeStart';\nconst TOAST_SWIPE_MOVE = 'toast.swipeMove';\nconst TOAST_SWIPE_CANCEL = 'toast.swipeCancel';\nconst TOAST_SWIPE_END = 'toast.swipeEnd';\n\ntype ToastElement = ToastImplElement;\ninterface ToastProps extends Omit<ToastImplProps, keyof ToastImplPrivateProps> {\n  open?: boolean;\n  defaultOpen?: boolean;\n  onOpenChange?(open: boolean): void;\n  /**\n   * Used to force mounting when more control is needed. Useful when\n   * controlling animation with React animation libraries.\n   */\n  forceMount?: true;\n}\n\nconst Toast = React.forwardRef<ToastElement, ToastProps>(\n  (props: ScopedProps<ToastProps>, forwardedRef) => {\n    const { forceMount, open: openProp, defaultOpen, onOpenChange, ...toastProps } = props;\n    const [open, setOpen] = useControllableState({\n      prop: openProp,\n      defaultProp: defaultOpen ?? true,\n      onChange: onOpenChange,\n      caller: TOAST_NAME,\n    });\n    return (\n      <Presence present={forceMount || open}>\n        <ToastImpl\n          open={open}\n          {...toastProps}\n          ref={forwardedRef}\n          onClose={() => setOpen(false)}\n          onPause={useCallbackRef(props.onPause)}\n          onResume={useCallbackRef(props.onResume)}\n          onSwipeStart={composeEventHandlers(props.onSwipeStart, (event) => {\n            event.currentTarget.setAttribute('data-swipe', 'start');\n          })}\n          onSwipeMove={composeEventHandlers(props.onSwipeMove, (event) => {\n            const { x, y } = event.detail.delta;\n            event.currentTarget.setAttribute('data-swipe', 'move');\n            event.currentTarget.style.setProperty('--radix-toast-swipe-move-x', `${x}px`);\n            event.currentTarget.style.setProperty('--radix-toast-swipe-move-y', `${y}px`);\n          })}\n          onSwipeCancel={composeEventHandlers(props.onSwipeCancel, (event) => {\n            event.currentTarget.setAttribute('data-swipe', 'cancel');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-x');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-y');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-end-x');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-end-y');\n          })}\n          onSwipeEnd={composeEventHandlers(props.onSwipeEnd, (event) => {\n            const { x, y } = event.detail.delta;\n            event.currentTarget.setAttribute('data-swipe', 'end');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-x');\n            event.currentTarget.style.removeProperty('--radix-toast-swipe-move-y');\n            event.currentTarget.style.setProperty('--radix-toast-swipe-end-x', `${x}px`);\n            event.currentTarget.style.setProperty('--radix-toast-swipe-end-y', `${y}px`);\n            setOpen(false);\n          })}\n        />\n      </Presence>\n    );\n  }\n);\n\nToast.displayName = TOAST_NAME;\n\n/* -----------------------------------------------------------------------------------------------*/\n\ntype SwipeEvent = { currentTarget: EventTarget & ToastElement } & Omit<\n  CustomEvent<{ originalEvent: React.PointerEvent; delta: { x: number; y: number } }>,\n  'currentTarget'\n>;\n\nconst [ToastInteractiveProvider, useToastInteractiveContext] = createToastContext(TOAST_NAME, {\n  onClose() {},\n});\n\ntype ToastImplElement = React.ComponentRef<typeof Primitive.li>;\ntype DismissableLayerProps = React.ComponentPropsWithoutRef<typeof DismissableLayer.Root>;\ntype ToastImplPrivateProps = { open: boolean; onClose(): void };\ntype PrimitiveListItemProps = React.ComponentPropsWithoutRef<typeof Primitive.li>;\ninterface ToastImplProps extends ToastImplPrivateProps, PrimitiveListItemProps {\n  type?: 'foreground' | 'background';\n  /**\n   * Time in milliseconds that toast should remain visible for. Overrides value\n   * given to `ToastProvider`.\n   */\n  duration?: number;\n  onEscapeKeyDown?: DismissableLayerProps['onEscapeKeyDown'];\n  onPause?(): void;\n  onResume?(): void;\n  onSwipeStart?(event: SwipeEvent): void;\n  onSwipeMove?(event: SwipeEvent): void;\n  onSwipeCancel?(event: SwipeEvent): void;\n  onSwipeEnd?(event: SwipeEvent): void;\n}\n\nconst ToastImpl = React.forwardRef<ToastImplElement, ToastImplProps>(\n  (props: ScopedProps<ToastImplProps>, forwardedRef) => {\n    const {\n      __scopeToast,\n      type = 'foreground',\n      duration: durationProp,\n      open,\n      onClose,\n      onEscapeKeyDown,\n      onPause,\n      onResume,\n      onSwipeStart,\n      onSwipeMove,\n      onSwipeCancel,\n      onSwipeEnd,\n      ...toastProps\n    } = props;\n    const context = useToastProviderContext(TOAST_NAME, __scopeToast);\n    const [node, setNode] = React.useState<ToastImplElement | null>(null);\n    const composedRefs = useComposedRefs(forwardedRef, (node) => setNode(node));\n    const pointerStartRef = React.useRef<{ x: number; y: number } | null>(null);\n    const swipeDeltaRef = React.useRef<{ x: number; y: number } | null>(null);\n    const duration = durationProp || context.duration;\n    const closeTimerStartTimeRef = React.useRef(0);\n    const closeTimerRemainingTimeRef = React.useRef(duration);\n    const closeTimerRef = React.useRef(0);\n    const { onToastAdd, onToastRemove } = context;\n    const handleClose = useCallbackRef(() => {\n      // focus viewport if focus is within toast to read the remaining toast\n      // count to SR users and ensure focus isn't lost\n      const isFocusInToast = node?.contains(document.activeElement);\n      if (isFocusInToast) context.viewport?.focus();\n      onClose();\n    });\n\n    const startTimer = React.useCallback(\n      (duration: number) => {\n        if (!duration || duration === Infinity) return;\n        window.clearTimeout(closeTimerRef.current);\n        closeTimerStartTimeRef.current = new Date().getTime();\n        closeTimerRef.current = window.setTimeout(handleClose, duration);\n      },\n      [handleClose]\n    );\n\n    React.useEffect(() => {\n      const viewport = context.viewport;\n      if (viewport) {\n        const handleResume = () => {\n          startTimer(closeTimerRemainingTimeRef.current);\n          onResume?.();\n        };\n        const handlePause = () => {\n          const elapsedTime = new Date().getTime() - closeTimerStartTimeRef.current;\n          closeTimerRemainingTimeRef.current = closeTimerRemainingTimeRef.current - elapsedTime;\n          window.clearTimeout(closeTimerRef.current);\n          onPause?.();\n        };\n        viewport.addEventListener(VIEWPORT_PAUSE, handlePause);\n        viewport.addEventListener(VIEWPORT_RESUME, handleResume);\n        return () => {\n          viewport.removeEventListener(VIEWPORT_PAUSE, handlePause);\n          viewport.removeEventListener(VIEWPORT_RESUME, handleResume);\n        };\n      }\n    }, [context.viewport, duration, onPause, onResume, startTimer]);\n\n    // start timer when toast opens or duration changes.\n    // we include `open` in deps because closed !== unmounted when animating\n    // so it could reopen before being completely unmounted\n    React.useEffect(() => {\n      if (open && !context.isClosePausedRef.current) startTimer(duration);\n    }, [open, duration, context.isClosePausedRef, startTimer]);\n\n    React.useEffect(() => {\n      onToastAdd();\n      return () => onToastRemove();\n    }, [onToastAdd, onToastRemove]);\n\n    const announceTextContent = React.useMemo(() => {\n      return node ? getAnnounceTextContent(node) : null;\n    }, [node]);\n\n    if (!context.viewport) return null;\n\n    return (\n      <>\n        {announceTextContent && (\n          <ToastAnnounce\n            __scopeToast={__scopeToast}\n            // Toasts are always role=status to avoid stuttering issues with role=alert in SRs.\n            role=\"status\"\n            aria-live={type === 'foreground' ? 'assertive' : 'polite'}\n            aria-atomic\n          >\n            {announceTextContent}\n          </ToastAnnounce>\n        )}\n\n        <ToastInteractiveProvider scope={__scopeToast} onClose={handleClose}>\n          {ReactDOM.createPortal(\n            <Collection.ItemSlot scope={__scopeToast}>\n              <DismissableLayer.Root\n                asChild\n                onEscapeKeyDown={composeEventHandlers(onEscapeKeyDown, () => {\n                  if (!context.isFocusedToastEscapeKeyDownRef.current) handleClose();\n                  context.isFocusedToastEscapeKeyDownRef.current = false;\n                })}\n              >\n                <Primitive.li\n                  // Ensure toasts are announced as status list or status when focused\n                  role=\"status\"\n                  aria-live=\"off\"\n                  aria-atomic\n                  tabIndex={0}\n                  data-state={open ? 'open' : 'closed'}\n                  data-swipe-direction={context.swipeDirection}\n                  {...toastProps}\n                  ref={composedRefs}\n                  style={{ userSelect: 'none', touchAction: 'none', ...props.style }}\n                  onKeyDown={composeEventHandlers(props.onKeyDown, (event) => {\n                    if (event.key !== 'Escape') return;\n                    onEscapeKeyDown?.(event.nativeEvent);\n                    if (!event.nativeEvent.defaultPrevented) {\n                      context.isFocusedToastEscapeKeyDownRef.current = true;\n                      handleClose();\n                    }\n                  })}\n                  onPointerDown={composeEventHandlers(props.onPointerDown, (event) => {\n                    if (event.button !== 0) return;\n                    pointerStartRef.current = { x: event.clientX, y: event.clientY };\n                  })}\n                  onPointerMove={composeEventHandlers(props.onPointerMove, (event) => {\n                    if (!pointerStartRef.current) return;\n                    const x = event.clientX - pointerStartRef.current.x;\n                    const y = event.clientY - pointerStartRef.current.y;\n                    const hasSwipeMoveStarted = Boolean(swipeDeltaRef.current);\n                    const isHorizontalSwipe = ['left', 'right'].includes(context.swipeDirection);\n                    const clamp = ['left', 'up'].includes(context.swipeDirection)\n                      ? Math.min\n                      : Math.max;\n                    const clampedX = isHorizontalSwipe ? clamp(0, x) : 0;\n                    const clampedY = !isHorizontalSwipe ? clamp(0, y) : 0;\n                    const moveStartBuffer = event.pointerType === 'touch' ? 10 : 2;\n                    const delta = { x: clampedX, y: clampedY };\n                    const eventDetail = { originalEvent: event, delta };\n                    if (hasSwipeMoveStarted) {\n                      swipeDeltaRef.current = delta;\n                      handleAndDispatchCustomEvent(TOAST_SWIPE_MOVE, onSwipeMove, eventDetail, {\n                        discrete: false,\n                      });\n                    } else if (isDeltaInDirection(delta, context.swipeDirection, moveStartBuffer)) {\n                      swipeDeltaRef.current = delta;\n                      handleAndDispatchCustomEvent(TOAST_SWIPE_START, onSwipeStart, eventDetail, {\n                        discrete: false,\n                      });\n                      (event.target as HTMLElement).setPointerCapture(event.pointerId);\n                    } else if (Math.abs(x) > moveStartBuffer || Math.abs(y) > moveStartBuffer) {\n                      // User is swiping in wrong direction so we disable swipe gesture\n                      // for the current pointer down interaction\n                      pointerStartRef.current = null;\n                    }\n                  })}\n                  onPointerUp={composeEventHandlers(props.onPointerUp, (event) => {\n                    const delta = swipeDeltaRef.current;\n                    const target = event.target as HTMLElement;\n                    if (target.hasPointerCapture(event.pointerId)) {\n                      target.releasePointerCapture(event.pointerId);\n                    }\n                    swipeDeltaRef.current = null;\n                    pointerStartRef.current = null;\n                    if (delta) {\n                      const toast = event.currentTarget;\n                      const eventDetail = { originalEvent: event, delta };\n                      if (\n                        isDeltaInDirection(delta, context.swipeDirection, context.swipeThreshold)\n                      ) {\n                        handleAndDispatchCustomEvent(TOAST_SWIPE_END, onSwipeEnd, eventDetail, {\n                          discrete: true,\n                        });\n                      } else {\n                        handleAndDispatchCustomEvent(\n                          TOAST_SWIPE_CANCEL,\n                          onSwipeCancel,\n                          eventDetail,\n                          {\n                            discrete: true,\n                          }\n                        );\n                      }\n                      // Prevent click event from triggering on items within the toast when\n                      // pointer up is part of a swipe gesture\n                      toast.addEventListener('click', (event) => event.preventDefault(), {\n                        once: true,\n                      });\n                    }\n                  })}\n                />\n              </DismissableLayer.Root>\n            </Collection.ItemSlot>,\n            context.viewport\n          )}\n        </ToastInteractiveProvider>\n      </>\n    );\n  }\n);\n\n/* -----------------------------------------------------------------------------------------------*/\n\ninterface ToastAnnounceProps\n  extends Omit<React.ComponentPropsWithoutRef<'div'>, 'children'>,\n    ScopedProps<{ children: string[] }> {}\n\nconst ToastAnnounce: React.FC<ToastAnnounceProps> = (props: ScopedProps<ToastAnnounceProps>) => {\n  const { __scopeToast, children, ...announceProps } = props;\n  const context = useToastProviderContext(TOAST_NAME, __scopeToast);\n  const [renderAnnounceText, setRenderAnnounceText] = React.useState(false);\n  const [isAnnounced, setIsAnnounced] = React.useState(false);\n\n  // render text content in the next frame to ensure toast is announced in NVDA\n  useNextFrame(() => setRenderAnnounceText(true));\n\n  // cleanup after announcing\n  React.useEffect(() => {\n    const timer = window.setTimeout(() => setIsAnnounced(true), 1000);\n    return () => window.clearTimeout(timer);\n  }, []);\n\n  return isAnnounced ? null : (\n    <Portal asChild>\n      <VisuallyHidden {...announceProps}>\n        {renderAnnounceText && (\n          <>\n            {context.label} {children}\n          </>\n        )}\n      </VisuallyHidden>\n    </Portal>\n  );\n};\n\n/* -------------------------------------------------------------------------------------------------\n * ToastTitle\n * -----------------------------------------------------------------------------------------------*/\n\nconst TITLE_NAME = 'ToastTitle';\n\ntype ToastTitleElement = React.ComponentRef<typeof Primitive.div>;\ntype PrimitiveDivProps = React.ComponentPropsWithoutRef<typeof Primitive.div>;\ninterface ToastTitleProps extends PrimitiveDivProps {}\n\nconst ToastTitle = React.forwardRef<ToastTitleElement, ToastTitleProps>(\n  (props: ScopedProps<ToastTitleProps>, forwardedRef) => {\n    const { __scopeToast, ...titleProps } = props;\n    return <Primitive.div {...titleProps} ref={forwardedRef} />;\n  }\n);\n\nToastTitle.displayName = TITLE_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastDescription\n * -----------------------------------------------------------------------------------------------*/\n\nconst DESCRIPTION_NAME = 'ToastDescription';\n\ntype ToastDescriptionElement = React.ComponentRef<typeof Primitive.div>;\ninterface ToastDescriptionProps extends PrimitiveDivProps {}\n\nconst ToastDescription = React.forwardRef<ToastDescriptionElement, ToastDescriptionProps>(\n  (props: ScopedProps<ToastDescriptionProps>, forwardedRef) => {\n    const { __scopeToast, ...descriptionProps } = props;\n    return <Primitive.div {...descriptionProps} ref={forwardedRef} />;\n  }\n);\n\nToastDescription.displayName = DESCRIPTION_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastAction\n * -----------------------------------------------------------------------------------------------*/\n\nconst ACTION_NAME = 'ToastAction';\n\ntype ToastActionElement = ToastCloseElement;\ninterface ToastActionProps extends ToastCloseProps {\n  /**\n   * A short description for an alternate way to carry out the action. For screen reader users\n   * who will not be able to navigate to the button easily/quickly.\n   * @example <ToastAction altText=\"Goto account settings to upgrade\">Upgrade</ToastAction>\n   * @example <ToastAction altText=\"Undo (Alt+U)\">Undo</ToastAction>\n   */\n  altText: string;\n}\n\nconst ToastAction = React.forwardRef<ToastActionElement, ToastActionProps>(\n  (props: ScopedProps<ToastActionProps>, forwardedRef) => {\n    const { altText, ...actionProps } = props;\n\n    if (!altText.trim()) {\n      console.error(\n        `Invalid prop \\`altText\\` supplied to \\`${ACTION_NAME}\\`. Expected non-empty \\`string\\`.`\n      );\n      return null;\n    }\n\n    return (\n      <ToastAnnounceExclude altText={altText} asChild>\n        <ToastClose {...actionProps} ref={forwardedRef} />\n      </ToastAnnounceExclude>\n    );\n  }\n);\n\nToastAction.displayName = ACTION_NAME;\n\n/* -------------------------------------------------------------------------------------------------\n * ToastClose\n * -----------------------------------------------------------------------------------------------*/\n\nconst CLOSE_NAME = 'ToastClose';\n\ntype ToastCloseElement = React.ComponentRef<typeof Primitive.button>;\ntype PrimitiveButtonProps = React.ComponentPropsWithoutRef<typeof Primitive.button>;\ninterface ToastCloseProps extends PrimitiveButtonProps {}\n\nconst ToastClose = React.forwardRef<ToastCloseElement, ToastCloseProps>(\n  (props: ScopedProps<ToastCloseProps>, forwardedRef) => {\n    const { __scopeToast, ...closeProps } = props;\n    const interactiveContext = useToastInteractiveContext(CLOSE_NAME, __scopeToast);\n\n    return (\n      <ToastAnnounceExclude asChild>\n        <Primitive.button\n          type=\"button\"\n          {...closeProps}\n          ref={forwardedRef}\n          onClick={composeEventHandlers(props.onClick, interactiveContext.onClose)}\n        />\n      </ToastAnnounceExclude>\n    );\n  }\n);\n\nToastClose.displayName = CLOSE_NAME;\n\n/* ---------------------------------------------------------------------------------------------- */\n\ntype ToastAnnounceExcludeElement = React.ComponentRef<typeof Primitive.div>;\ninterface ToastAnnounceExcludeProps extends PrimitiveDivProps {\n  altText?: string;\n}\n\nconst ToastAnnounceExclude = React.forwardRef<\n  ToastAnnounceExcludeElement,\n  ToastAnnounceExcludeProps\n>((props: ScopedProps<ToastAnnounceExcludeProps>, forwardedRef) => {\n  const { __scopeToast, altText, ...announceExcludeProps } = props;\n\n  return (\n    <Primitive.div\n      data-radix-toast-announce-exclude=\"\"\n      data-radix-toast-announce-alt={altText || undefined}\n      {...announceExcludeProps}\n      ref={forwardedRef}\n    />\n  );\n});\n\nfunction getAnnounceTextContent(container: HTMLElement) {\n  const textContent: string[] = [];\n  const childNodes = Array.from(container.childNodes);\n\n  childNodes.forEach((node) => {\n    if (node.nodeType === node.TEXT_NODE && node.textContent) textContent.push(node.textContent);\n    if (isHTMLElement(node)) {\n      const isHidden = node.ariaHidden || node.hidden || node.style.display === 'none';\n      const isExcluded = node.dataset.radixToastAnnounceExclude === '';\n\n      if (!isHidden) {\n        if (isExcluded) {\n          const altText = node.dataset.radixToastAnnounceAlt;\n          if (altText) textContent.push(altText);\n        } else {\n          textContent.push(...getAnnounceTextContent(node));\n        }\n      }\n    }\n  });\n\n  // We return a collection of text rather than a single concatenated string.\n  // This allows SR VO to naturally pause break between nodes while announcing.\n  return textContent;\n}\n\n/* ---------------------------------------------------------------------------------------------- */\n\nfunction handleAndDispatchCustomEvent<\n  E extends CustomEvent,\n  ReactEvent extends React.SyntheticEvent,\n>(\n  name: string,\n  handler: ((event: E) => void) | undefined,\n  detail: { originalEvent: ReactEvent } & (E extends CustomEvent<infer D> ? D : never),\n  { discrete }: { discrete: boolean }\n) {\n  const currentTarget = detail.originalEvent.currentTarget as HTMLElement;\n  const event = new CustomEvent(name, { bubbles: true, cancelable: true, detail });\n  if (handler) currentTarget.addEventListener(name, handler as EventListener, { once: true });\n\n  if (discrete) {\n    dispatchDiscreteCustomEvent(currentTarget, event);\n  } else {\n    currentTarget.dispatchEvent(event);\n  }\n}\n\nconst isDeltaInDirection = (\n  delta: { x: number; y: number },\n  direction: SwipeDirection,\n  threshold = 0\n) => {\n  const deltaX = Math.abs(delta.x);\n  const deltaY = Math.abs(delta.y);\n  const isDeltaX = deltaX > deltaY;\n  if (direction === 'left' || direction === 'right') {\n    return isDeltaX && deltaX > threshold;\n  } else {\n    return !isDeltaX && deltaY > threshold;\n  }\n};\n\nfunction useNextFrame(callback = () => {}) {\n  const fn = useCallbackRef(callback);\n  useLayoutEffect(() => {\n    let raf1 = 0;\n    let raf2 = 0;\n    raf1 = window.requestAnimationFrame(() => (raf2 = window.requestAnimationFrame(fn)));\n    return () => {\n      window.cancelAnimationFrame(raf1);\n      window.cancelAnimationFrame(raf2);\n    };\n  }, [fn]);\n}\n\nfunction isHTMLElement(node: any): node is HTMLElement {\n  return node.nodeType === node.ELEMENT_NODE;\n}\n\n/**\n * Returns a list of potential tabbable candidates.\n *\n * NOTE: This is only a close approximation. For example it doesn't take into account cases like when\n * elements are not visible. This cannot be worked out easily by just reading a property, but rather\n * necessitate runtime knowledge (computed styles, etc). We deal with these cases separately.\n *\n * See: https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker\n * Credit: https://github.com/discord/focus-layers/blob/master/src/util/wrapFocus.tsx#L1\n */\nfunction getTabbableCandidates(container: HTMLElement) {\n  const nodes: HTMLElement[] = [];\n  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n    acceptNode: (node: any) => {\n      const isHiddenInput = node.tagName === 'INPUT' && node.type === 'hidden';\n      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;\n      // `.tabIndex` is not the same as the `tabindex` attribute. It works on the\n      // runtime's understanding of tabbability, so this automatically accounts\n      // for any kind of element that could be tabbed to.\n      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;\n    },\n  });\n  while (walker.nextNode()) nodes.push(walker.currentNode as HTMLElement);\n  // we do not take into account the order of nodes with positive `tabIndex` as it\n  // hinders accessibility to have tab order different from visual order.\n  return nodes;\n}\n\nfunction focusFirst(candidates: HTMLElement[]) {\n  const previouslyFocusedElement = document.activeElement;\n  return candidates.some((candidate) => {\n    // if focus is already where we want to go, we don't want to keep going through the candidates\n    if (candidate === previouslyFocusedElement) return true;\n    candidate.focus();\n    return document.activeElement !== previouslyFocusedElement;\n  });\n}\n\nconst Provider = ToastProvider;\nconst Viewport = ToastViewport;\nconst Root = Toast;\nconst Title = ToastTitle;\nconst Description = ToastDescription;\nconst Action = ToastAction;\nconst Close = ToastClose;\n\nexport {\n  createToastScope,\n  //\n  ToastProvider,\n  ToastViewport,\n  Toast,\n  ToastTitle,\n  ToastDescription,\n  ToastAction,\n  ToastClose,\n  //\n  Provider,\n  Viewport,\n  Root,\n  Title,\n  Description,\n  Action,\n  Close,\n};\nexport type {\n  ToastProviderProps,\n  ToastViewportProps,\n  ToastProps,\n  ToastTitleProps,\n  ToastDescriptionProps,\n  ToastActionProps,\n  ToastCloseProps,\n};\n","'use client'\n\nimport * as Devtools from './ReactQueryDevtools'\nimport * as DevtoolsPanel from './ReactQueryDevtoolsPanel'\n\nexport const ReactQueryDevtools: (typeof Devtools)['ReactQueryDevtools'] =\n  process.env.NODE_ENV !== 'development'\n    ? function () {\n        return null\n      }\n    : Devtools.ReactQueryDevtools\n\nexport const ReactQueryDevtoolsPanel: (typeof DevtoolsPanel)['ReactQueryDevtoolsPanel'] =\n  process.env.NODE_ENV !== 'development'\n    ? function () {\n        return null\n      }\n    : DevtoolsPanel.ReactQueryDevtoolsPanel\n","// src/queryCache.ts\nimport { hashQueryKeyByOptions, matchQuery } from \"./utils.js\";\nimport { Query } from \"./query.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { Subscribable } from \"./subscribable.js\";\nvar QueryCache = class extends Subscribable {\n  constructor(config = {}) {\n    super();\n    this.config = config;\n    this.#queries = /* @__PURE__ */ new Map();\n  }\n  #queries;\n  build(client, options, state) {\n    const queryKey = options.queryKey;\n    const queryHash = options.queryHash ?? hashQueryKeyByOptions(queryKey, options);\n    let query = this.get(queryHash);\n    if (!query) {\n      query = new Query({\n        client,\n        queryKey,\n        queryHash,\n        options: client.defaultQueryOptions(options),\n        state,\n        defaultOptions: client.getQueryDefaults(queryKey)\n      });\n      this.add(query);\n    }\n    return query;\n  }\n  add(query) {\n    if (!this.#queries.has(query.queryHash)) {\n      this.#queries.set(query.queryHash, query);\n      this.notify({\n        type: \"added\",\n        query\n      });\n    }\n  }\n  remove(query) {\n    const queryInMap = this.#queries.get(query.queryHash);\n    if (queryInMap) {\n      query.destroy();\n      if (queryInMap === query) {\n        this.#queries.delete(query.queryHash);\n      }\n      this.notify({ type: \"removed\", query });\n    }\n  }\n  clear() {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        this.remove(query);\n      });\n    });\n  }\n  get(queryHash) {\n    return this.#queries.get(queryHash);\n  }\n  getAll() {\n    return [...this.#queries.values()];\n  }\n  find(filters) {\n    const defaultedFilters = { exact: true, ...filters };\n    return this.getAll().find(\n      (query) => matchQuery(defaultedFilters, query)\n    );\n  }\n  findAll(filters = {}) {\n    const queries = this.getAll();\n    return Object.keys(filters).length > 0 ? queries.filter((query) => matchQuery(filters, query)) : queries;\n  }\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event);\n      });\n    });\n  }\n  onFocus() {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onFocus();\n      });\n    });\n  }\n  onOnline() {\n    notifyManager.batch(() => {\n      this.getAll().forEach((query) => {\n        query.onOnline();\n      });\n    });\n  }\n};\nexport {\n  QueryCache\n};\n//# sourceMappingURL=queryCache.js.map","// src/mutationCache.ts\nimport { notifyManager } from \"./notifyManager.js\";\nimport { Mutation } from \"./mutation.js\";\nimport { matchMutation, noop } from \"./utils.js\";\nimport { Subscribable } from \"./subscribable.js\";\nvar MutationCache = class extends Subscribable {\n  constructor(config = {}) {\n    super();\n    this.config = config;\n    this.#mutations = /* @__PURE__ */ new Set();\n    this.#scopes = /* @__PURE__ */ new Map();\n    this.#mutationId = 0;\n  }\n  #mutations;\n  #scopes;\n  #mutationId;\n  build(client, options, state) {\n    const mutation = new Mutation({\n      mutationCache: this,\n      mutationId: ++this.#mutationId,\n      options: client.defaultMutationOptions(options),\n      state\n    });\n    this.add(mutation);\n    return mutation;\n  }\n  add(mutation) {\n    this.#mutations.add(mutation);\n    const scope = scopeFor(mutation);\n    if (typeof scope === \"string\") {\n      const scopedMutations = this.#scopes.get(scope);\n      if (scopedMutations) {\n        scopedMutations.push(mutation);\n      } else {\n        this.#scopes.set(scope, [mutation]);\n      }\n    }\n    this.notify({ type: \"added\", mutation });\n  }\n  remove(mutation) {\n    if (this.#mutations.delete(mutation)) {\n      const scope = scopeFor(mutation);\n      if (typeof scope === \"string\") {\n        const scopedMutations = this.#scopes.get(scope);\n        if (scopedMutations) {\n          if (scopedMutations.length > 1) {\n            const index = scopedMutations.indexOf(mutation);\n            if (index !== -1) {\n              scopedMutations.splice(index, 1);\n            }\n          } else if (scopedMutations[0] === mutation) {\n            this.#scopes.delete(scope);\n          }\n        }\n      }\n    }\n    this.notify({ type: \"removed\", mutation });\n  }\n  canRun(mutation) {\n    const scope = scopeFor(mutation);\n    if (typeof scope === \"string\") {\n      const mutationsWithSameScope = this.#scopes.get(scope);\n      const firstPendingMutation = mutationsWithSameScope?.find(\n        (m) => m.state.status === \"pending\"\n      );\n      return !firstPendingMutation || firstPendingMutation === mutation;\n    } else {\n      return true;\n    }\n  }\n  runNext(mutation) {\n    const scope = scopeFor(mutation);\n    if (typeof scope === \"string\") {\n      const foundMutation = this.#scopes.get(scope)?.find((m) => m !== mutation && m.state.isPaused);\n      return foundMutation?.continue() ?? Promise.resolve();\n    } else {\n      return Promise.resolve();\n    }\n  }\n  clear() {\n    notifyManager.batch(() => {\n      this.#mutations.forEach((mutation) => {\n        this.notify({ type: \"removed\", mutation });\n      });\n      this.#mutations.clear();\n      this.#scopes.clear();\n    });\n  }\n  getAll() {\n    return Array.from(this.#mutations);\n  }\n  find(filters) {\n    const defaultedFilters = { exact: true, ...filters };\n    return this.getAll().find(\n      (mutation) => matchMutation(defaultedFilters, mutation)\n    );\n  }\n  findAll(filters = {}) {\n    return this.getAll().filter((mutation) => matchMutation(filters, mutation));\n  }\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach((listener) => {\n        listener(event);\n      });\n    });\n  }\n  resumePausedMutations() {\n    const pausedMutations = this.getAll().filter((x) => x.state.isPaused);\n    return notifyManager.batch(\n      () => Promise.all(\n        pausedMutations.map((mutation) => mutation.continue().catch(noop))\n      )\n    );\n  }\n};\nfunction scopeFor(mutation) {\n  return mutation.options.scope?.id;\n}\nexport {\n  MutationCache\n};\n//# sourceMappingURL=mutationCache.js.map","// src/infiniteQueryBehavior.ts\nimport { addToEnd, addToStart, ensureQueryFn } from \"./utils.js\";\nfunction infiniteQueryBehavior(pages) {\n  return {\n    onFetch: (context, query) => {\n      const options = context.options;\n      const direction = context.fetchOptions?.meta?.fetchMore?.direction;\n      const oldPages = context.state.data?.pages || [];\n      const oldPageParams = context.state.data?.pageParams || [];\n      let result = { pages: [], pageParams: [] };\n      let currentPage = 0;\n      const fetchFn = async () => {\n        let cancelled = false;\n        const addSignalProperty = (object) => {\n          Object.defineProperty(object, \"signal\", {\n            enumerable: true,\n            get: () => {\n              if (context.signal.aborted) {\n                cancelled = true;\n              } else {\n                context.signal.addEventListener(\"abort\", () => {\n                  cancelled = true;\n                });\n              }\n              return context.signal;\n            }\n          });\n        };\n        const queryFn = ensureQueryFn(context.options, context.fetchOptions);\n        const fetchPage = async (data, param, previous) => {\n          if (cancelled) {\n            return Promise.reject();\n          }\n          if (param == null && data.pages.length) {\n            return Promise.resolve(data);\n          }\n          const createQueryFnContext = () => {\n            const queryFnContext2 = {\n              client: context.client,\n              queryKey: context.queryKey,\n              pageParam: param,\n              direction: previous ? \"backward\" : \"forward\",\n              meta: context.options.meta\n            };\n            addSignalProperty(queryFnContext2);\n            return queryFnContext2;\n          };\n          const queryFnContext = createQueryFnContext();\n          const page = await queryFn(queryFnContext);\n          const { maxPages } = context.options;\n          const addTo = previous ? addToStart : addToEnd;\n          return {\n            pages: addTo(data.pages, page, maxPages),\n            pageParams: addTo(data.pageParams, param, maxPages)\n          };\n        };\n        if (direction && oldPages.length) {\n          const previous = direction === \"backward\";\n          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;\n          const oldData = {\n            pages: oldPages,\n            pageParams: oldPageParams\n          };\n          const param = pageParamFn(options, oldData);\n          result = await fetchPage(oldData, param, previous);\n        } else {\n          const remainingPages = pages ?? oldPages.length;\n          do {\n            const param = currentPage === 0 ? oldPageParams[0] ?? options.initialPageParam : getNextPageParam(options, result);\n            if (currentPage > 0 && param == null) {\n              break;\n            }\n            result = await fetchPage(result, param);\n            currentPage++;\n          } while (currentPage < remainingPages);\n        }\n        return result;\n      };\n      if (context.options.persister) {\n        context.fetchFn = () => {\n          return context.options.persister?.(\n            fetchFn,\n            {\n              client: context.client,\n              queryKey: context.queryKey,\n              meta: context.options.meta,\n              signal: context.signal\n            },\n            query\n          );\n        };\n      } else {\n        context.fetchFn = fetchFn;\n      }\n    }\n  };\n}\nfunction getNextPageParam(options, { pages, pageParams }) {\n  const lastIndex = pages.length - 1;\n  return pages.length > 0 ? options.getNextPageParam(\n    pages[lastIndex],\n    pages,\n    pageParams[lastIndex],\n    pageParams\n  ) : void 0;\n}\nfunction getPreviousPageParam(options, { pages, pageParams }) {\n  return pages.length > 0 ? options.getPreviousPageParam?.(pages[0], pages, pageParams[0], pageParams) : void 0;\n}\nfunction hasNextPage(options, data) {\n  if (!data) return false;\n  return getNextPageParam(options, data) != null;\n}\nfunction hasPreviousPage(options, data) {\n  if (!data || !options.getPreviousPageParam) return false;\n  return getPreviousPageParam(options, data) != null;\n}\nexport {\n  hasNextPage,\n  hasPreviousPage,\n  infiniteQueryBehavior\n};\n//# sourceMappingURL=infiniteQueryBehavior.js.map","// src/queryClient.ts\nimport {\n  functionalUpdate,\n  hashKey,\n  hashQueryKeyByOptions,\n  noop,\n  partialMatchKey,\n  resolveStaleTime,\n  skipToken\n} from \"./utils.js\";\nimport { QueryCache } from \"./queryCache.js\";\nimport { MutationCache } from \"./mutationCache.js\";\nimport { focusManager } from \"./focusManager.js\";\nimport { onlineManager } from \"./onlineManager.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { infiniteQueryBehavior } from \"./infiniteQueryBehavior.js\";\nvar QueryClient = class {\n  #queryCache;\n  #mutationCache;\n  #defaultOptions;\n  #queryDefaults;\n  #mutationDefaults;\n  #mountCount;\n  #unsubscribeFocus;\n  #unsubscribeOnline;\n  constructor(config = {}) {\n    this.#queryCache = config.queryCache || new QueryCache();\n    this.#mutationCache = config.mutationCache || new MutationCache();\n    this.#defaultOptions = config.defaultOptions || {};\n    this.#queryDefaults = /* @__PURE__ */ new Map();\n    this.#mutationDefaults = /* @__PURE__ */ new Map();\n    this.#mountCount = 0;\n  }\n  mount() {\n    this.#mountCount++;\n    if (this.#mountCount !== 1) return;\n    this.#unsubscribeFocus = focusManager.subscribe(async (focused) => {\n      if (focused) {\n        await this.resumePausedMutations();\n        this.#queryCache.onFocus();\n      }\n    });\n    this.#unsubscribeOnline = onlineManager.subscribe(async (online) => {\n      if (online) {\n        await this.resumePausedMutations();\n        this.#queryCache.onOnline();\n      }\n    });\n  }\n  unmount() {\n    this.#mountCount--;\n    if (this.#mountCount !== 0) return;\n    this.#unsubscribeFocus?.();\n    this.#unsubscribeFocus = void 0;\n    this.#unsubscribeOnline?.();\n    this.#unsubscribeOnline = void 0;\n  }\n  isFetching(filters) {\n    return this.#queryCache.findAll({ ...filters, fetchStatus: \"fetching\" }).length;\n  }\n  isMutating(filters) {\n    return this.#mutationCache.findAll({ ...filters, status: \"pending\" }).length;\n  }\n  /**\n   * Imperative (non-reactive) way to retrieve data for a QueryKey.\n   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.\n   *\n   * Hint: Do not use this function inside a component, because it won't receive updates.\n   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.\n   */\n  getQueryData(queryKey) {\n    const options = this.defaultQueryOptions({ queryKey });\n    return this.#queryCache.get(options.queryHash)?.state.data;\n  }\n  ensureQueryData(options) {\n    const defaultedOptions = this.defaultQueryOptions(options);\n    const query = this.#queryCache.build(this, defaultedOptions);\n    const cachedData = query.state.data;\n    if (cachedData === void 0) {\n      return this.fetchQuery(options);\n    }\n    if (options.revalidateIfStale && query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))) {\n      void this.prefetchQuery(defaultedOptions);\n    }\n    return Promise.resolve(cachedData);\n  }\n  getQueriesData(filters) {\n    return this.#queryCache.findAll(filters).map(({ queryKey, state }) => {\n      const data = state.data;\n      return [queryKey, data];\n    });\n  }\n  setQueryData(queryKey, updater, options) {\n    const defaultedOptions = this.defaultQueryOptions({ queryKey });\n    const query = this.#queryCache.get(\n      defaultedOptions.queryHash\n    );\n    const prevData = query?.state.data;\n    const data = functionalUpdate(updater, prevData);\n    if (data === void 0) {\n      return void 0;\n    }\n    return this.#queryCache.build(this, defaultedOptions).setData(data, { ...options, manual: true });\n  }\n  setQueriesData(filters, updater, options) {\n    return notifyManager.batch(\n      () => this.#queryCache.findAll(filters).map(({ queryKey }) => [\n        queryKey,\n        this.setQueryData(queryKey, updater, options)\n      ])\n    );\n  }\n  getQueryState(queryKey) {\n    const options = this.defaultQueryOptions({ queryKey });\n    return this.#queryCache.get(\n      options.queryHash\n    )?.state;\n  }\n  removeQueries(filters) {\n    const queryCache = this.#queryCache;\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        queryCache.remove(query);\n      });\n    });\n  }\n  resetQueries(filters, options) {\n    const queryCache = this.#queryCache;\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach((query) => {\n        query.reset();\n      });\n      return this.refetchQueries(\n        {\n          type: \"active\",\n          ...filters\n        },\n        options\n      );\n    });\n  }\n  cancelQueries(filters, cancelOptions = {}) {\n    const defaultedCancelOptions = { revert: true, ...cancelOptions };\n    const promises = notifyManager.batch(\n      () => this.#queryCache.findAll(filters).map((query) => query.cancel(defaultedCancelOptions))\n    );\n    return Promise.all(promises).then(noop).catch(noop);\n  }\n  invalidateQueries(filters, options = {}) {\n    return notifyManager.batch(() => {\n      this.#queryCache.findAll(filters).forEach((query) => {\n        query.invalidate();\n      });\n      if (filters?.refetchType === \"none\") {\n        return Promise.resolve();\n      }\n      return this.refetchQueries(\n        {\n          ...filters,\n          type: filters?.refetchType ?? filters?.type ?? \"active\"\n        },\n        options\n      );\n    });\n  }\n  refetchQueries(filters, options = {}) {\n    const fetchOptions = {\n      ...options,\n      cancelRefetch: options.cancelRefetch ?? true\n    };\n    const promises = notifyManager.batch(\n      () => this.#queryCache.findAll(filters).filter((query) => !query.isDisabled() && !query.isStatic()).map((query) => {\n        let promise = query.fetch(void 0, fetchOptions);\n        if (!fetchOptions.throwOnError) {\n          promise = promise.catch(noop);\n        }\n        return query.state.fetchStatus === \"paused\" ? Promise.resolve() : promise;\n      })\n    );\n    return Promise.all(promises).then(noop);\n  }\n  fetchQuery(options) {\n    const defaultedOptions = this.defaultQueryOptions(options);\n    if (defaultedOptions.retry === void 0) {\n      defaultedOptions.retry = false;\n    }\n    const query = this.#queryCache.build(this, defaultedOptions);\n    return query.isStaleByTime(\n      resolveStaleTime(defaultedOptions.staleTime, query)\n    ) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n  }\n  prefetchQuery(options) {\n    return this.fetchQuery(options).then(noop).catch(noop);\n  }\n  fetchInfiniteQuery(options) {\n    options.behavior = infiniteQueryBehavior(options.pages);\n    return this.fetchQuery(options);\n  }\n  prefetchInfiniteQuery(options) {\n    return this.fetchInfiniteQuery(options).then(noop).catch(noop);\n  }\n  ensureInfiniteQueryData(options) {\n    options.behavior = infiniteQueryBehavior(options.pages);\n    return this.ensureQueryData(options);\n  }\n  resumePausedMutations() {\n    if (onlineManager.isOnline()) {\n      return this.#mutationCache.resumePausedMutations();\n    }\n    return Promise.resolve();\n  }\n  getQueryCache() {\n    return this.#queryCache;\n  }\n  getMutationCache() {\n    return this.#mutationCache;\n  }\n  getDefaultOptions() {\n    return this.#defaultOptions;\n  }\n  setDefaultOptions(options) {\n    this.#defaultOptions = options;\n  }\n  setQueryDefaults(queryKey, options) {\n    this.#queryDefaults.set(hashKey(queryKey), {\n      queryKey,\n      defaultOptions: options\n    });\n  }\n  getQueryDefaults(queryKey) {\n    const defaults = [...this.#queryDefaults.values()];\n    const result = {};\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(queryKey, queryDefault.queryKey)) {\n        Object.assign(result, queryDefault.defaultOptions);\n      }\n    });\n    return result;\n  }\n  setMutationDefaults(mutationKey, options) {\n    this.#mutationDefaults.set(hashKey(mutationKey), {\n      mutationKey,\n      defaultOptions: options\n    });\n  }\n  getMutationDefaults(mutationKey) {\n    const defaults = [...this.#mutationDefaults.values()];\n    const result = {};\n    defaults.forEach((queryDefault) => {\n      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {\n        Object.assign(result, queryDefault.defaultOptions);\n      }\n    });\n    return result;\n  }\n  defaultQueryOptions(options) {\n    if (options._defaulted) {\n      return options;\n    }\n    const defaultedOptions = {\n      ...this.#defaultOptions.queries,\n      ...this.getQueryDefaults(options.queryKey),\n      ...options,\n      _defaulted: true\n    };\n    if (!defaultedOptions.queryHash) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(\n        defaultedOptions.queryKey,\n        defaultedOptions\n      );\n    }\n    if (defaultedOptions.refetchOnReconnect === void 0) {\n      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== \"always\";\n    }\n    if (defaultedOptions.throwOnError === void 0) {\n      defaultedOptions.throwOnError = !!defaultedOptions.suspense;\n    }\n    if (!defaultedOptions.networkMode && defaultedOptions.persister) {\n      defaultedOptions.networkMode = \"offlineFirst\";\n    }\n    if (defaultedOptions.queryFn === skipToken) {\n      defaultedOptions.enabled = false;\n    }\n    return defaultedOptions;\n  }\n  defaultMutationOptions(options) {\n    if (options?._defaulted) {\n      return options;\n    }\n    return {\n      ...this.#defaultOptions.mutations,\n      ...options?.mutationKey && this.getMutationDefaults(options.mutationKey),\n      ...options,\n      _defaulted: true\n    };\n  }\n  clear() {\n    this.#queryCache.clear();\n    this.#mutationCache.clear();\n  }\n};\nexport {\n  QueryClient\n};\n//# sourceMappingURL=queryClient.js.map","// extracted by mini-css-extract-plugin\nmodule.exports = {\"style\":{\"fontFamily\":\"'geistSans', 'geistSans Fallback'\"},\"className\":\"__className_1e4310\",\"variable\":\"__variable_1e4310\"};","import createLucideIcon from '../createLucideIcon';\nimport { IconNode } from '../types';\n\nexport const __iconNode: IconNode = [\n  ['path', { d: 'M18 6 6 18', key: '1bl5f8' }],\n  ['path', { d: 'm6 6 12 12', key: 'd8bk6v' }],\n];\n\n/**\n * @component @name X\n * @description Lucide SVG icon component, renders SVG Element with children.\n *\n * @preview ![img](data:image/svg+xml;base64,PHN2ZyAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogIHdpZHRoPSIyNCIKICBoZWlnaHQ9IjI0IgogIHZpZXdCb3g9IjAgMCAyNCAyNCIKICBmaWxsPSJub25lIgogIHN0cm9rZT0iIzAwMCIgc3R5bGU9ImJhY2tncm91bmQtY29sb3I6ICNmZmY7IGJvcmRlci1yYWRpdXM6IDJweCIKICBzdHJva2Utd2lkdGg9IjIiCiAgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIgogIHN0cm9rZS1saW5lam9pbj0icm91bmQiCj4KICA8cGF0aCBkPSJNMTggNiA2IDE4IiAvPgogIDxwYXRoIGQ9Im02IDYgMTIgMTIiIC8+Cjwvc3ZnPgo=) - https://lucide.dev/icons/x\n * @see https://lucide.dev/guide/packages/lucide-react - Documentation\n *\n * @param {Object} props - Lucide icons props and any valid SVG attribute\n * @returns {JSX.Element} JSX Element\n *\n */\nconst X = createLucideIcon('x', __iconNode);\n\nexport default X;\n","import * as React from 'react';\nimport { useComposedRefs } from '@radix-ui/react-compose-refs';\nimport { useLayoutEffect } from '@radix-ui/react-use-layout-effect';\nimport { useStateMachine } from './use-state-machine';\n\ninterface PresenceProps {\n  children: React.ReactElement | ((props: { present: boolean }) => React.ReactElement);\n  present: boolean;\n}\n\nconst Presence: React.FC<PresenceProps> = (props) => {\n  const { present, children } = props;\n  const presence = usePresence(present);\n\n  const child = (\n    typeof children === 'function'\n      ? children({ present: presence.isPresent })\n      : React.Children.only(children)\n  ) as React.ReactElement<{ ref?: React.Ref<HTMLElement> }>;\n\n  const ref = useComposedRefs(presence.ref, getElementRef(child));\n  const forceMount = typeof children === 'function';\n  return forceMount || presence.isPresent ? React.cloneElement(child, { ref }) : null;\n};\n\nPresence.displayName = 'Presence';\n\n/* -------------------------------------------------------------------------------------------------\n * usePresence\n * -----------------------------------------------------------------------------------------------*/\n\nfunction usePresence(present: boolean) {\n  const [node, setNode] = React.useState<HTMLElement>();\n  const stylesRef = React.useRef<CSSStyleDeclaration | null>(null);\n  const prevPresentRef = React.useRef(present);\n  const prevAnimationNameRef = React.useRef<string>('none');\n  const initialState = present ? 'mounted' : 'unmounted';\n  const [state, send] = useStateMachine(initialState, {\n    mounted: {\n      UNMOUNT: 'unmounted',\n      ANIMATION_OUT: 'unmountSuspended',\n    },\n    unmountSuspended: {\n      MOUNT: 'mounted',\n      ANIMATION_END: 'unmounted',\n    },\n    unmounted: {\n      MOUNT: 'mounted',\n    },\n  });\n\n  React.useEffect(() => {\n    const currentAnimationName = getAnimationName(stylesRef.current);\n    prevAnimationNameRef.current = state === 'mounted' ? currentAnimationName : 'none';\n  }, [state]);\n\n  useLayoutEffect(() => {\n    const styles = stylesRef.current;\n    const wasPresent = prevPresentRef.current;\n    const hasPresentChanged = wasPresent !== present;\n\n    if (hasPresentChanged) {\n      const prevAnimationName = prevAnimationNameRef.current;\n      const currentAnimationName = getAnimationName(styles);\n\n      if (present) {\n        send('MOUNT');\n      } else if (currentAnimationName === 'none' || styles?.display === 'none') {\n        // If there is no exit animation or the element is hidden, animations won't run\n        // so we unmount instantly\n        send('UNMOUNT');\n      } else {\n        /**\n         * When `present` changes to `false`, we check changes to animation-name to\n         * determine whether an animation has started. We chose this approach (reading\n         * computed styles) because there is no `animationrun` event and `animationstart`\n         * fires after `animation-delay` has expired which would be too late.\n         */\n        const isAnimating = prevAnimationName !== currentAnimationName;\n\n        if (wasPresent && isAnimating) {\n          send('ANIMATION_OUT');\n        } else {\n          send('UNMOUNT');\n        }\n      }\n\n      prevPresentRef.current = present;\n    }\n  }, [present, send]);\n\n  useLayoutEffect(() => {\n    if (node) {\n      let timeoutId: number;\n      const ownerWindow = node.ownerDocument.defaultView ?? window;\n      /**\n       * Triggering an ANIMATION_OUT during an ANIMATION_IN will fire an `animationcancel`\n       * event for ANIMATION_IN after we have entered `unmountSuspended` state. So, we\n       * make sure we only trigger ANIMATION_END for the currently active animation.\n       */\n      const handleAnimationEnd = (event: AnimationEvent) => {\n        const currentAnimationName = getAnimationName(stylesRef.current);\n        const isCurrentAnimation = currentAnimationName.includes(event.animationName);\n        if (event.target === node && isCurrentAnimation) {\n          // With React 18 concurrency this update is applied a frame after the\n          // animation ends, creating a flash of visible content. By setting the\n          // animation fill mode to \"forwards\", we force the node to keep the\n          // styles of the last keyframe, removing the flash.\n          //\n          // Previously we flushed the update via ReactDom.flushSync, but with\n          // exit animations this resulted in the node being removed from the\n          // DOM before the synthetic animationEnd event was dispatched, meaning\n          // user-provided event handlers would not be called.\n          // https://github.com/radix-ui/primitives/pull/1849\n          send('ANIMATION_END');\n          if (!prevPresentRef.current) {\n            const currentFillMode = node.style.animationFillMode;\n            node.style.animationFillMode = 'forwards';\n            // Reset the style after the node had time to unmount (for cases\n            // where the component chooses not to unmount). Doing this any\n            // sooner than `setTimeout` (e.g. with `requestAnimationFrame`)\n            // still causes a flash.\n            timeoutId = ownerWindow.setTimeout(() => {\n              if (node.style.animationFillMode === 'forwards') {\n                node.style.animationFillMode = currentFillMode;\n              }\n            });\n          }\n        }\n      };\n      const handleAnimationStart = (event: AnimationEvent) => {\n        if (event.target === node) {\n          // if animation occurred, store its name as the previous animation.\n          prevAnimationNameRef.current = getAnimationName(stylesRef.current);\n        }\n      };\n      node.addEventListener('animationstart', handleAnimationStart);\n      node.addEventListener('animationcancel', handleAnimationEnd);\n      node.addEventListener('animationend', handleAnimationEnd);\n      return () => {\n        ownerWindow.clearTimeout(timeoutId);\n        node.removeEventListener('animationstart', handleAnimationStart);\n        node.removeEventListener('animationcancel', handleAnimationEnd);\n        node.removeEventListener('animationend', handleAnimationEnd);\n      };\n    } else {\n      // Transition to the unmounted state if the node is removed prematurely.\n      // We avoid doing so during cleanup as the node may change but still exist.\n      send('ANIMATION_END');\n    }\n  }, [node, send]);\n\n  return {\n    isPresent: ['mounted', 'unmountSuspended'].includes(state),\n    ref: React.useCallback((node: HTMLElement) => {\n      stylesRef.current = node ? getComputedStyle(node) : null;\n      setNode(node);\n    }, []),\n  };\n}\n\n/* -----------------------------------------------------------------------------------------------*/\n\nfunction getAnimationName(styles: CSSStyleDeclaration | null) {\n  return styles?.animationName || 'none';\n}\n\n// Before React 19 accessing `element.props.ref` will throw a warning and suggest using `element.ref`\n// After React 19 accessing `element.ref` does the opposite.\n// https://github.com/facebook/react/pull/28348\n//\n// Access the ref using the method that doesn't yield a warning.\nfunction getElementRef(element: React.ReactElement<{ ref?: React.Ref<unknown> }>) {\n  // React <=18 in DEV\n  let getter = Object.getOwnPropertyDescriptor(element.props, 'ref')?.get;\n  let mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return (element as any).ref;\n  }\n\n  // React 19 in DEV\n  getter = Object.getOwnPropertyDescriptor(element, 'ref')?.get;\n  mayWarn = getter && 'isReactWarning' in getter && getter.isReactWarning;\n  if (mayWarn) {\n    return element.props.ref;\n  }\n\n  // Not DEV\n  return element.props.ref || (element as any).ref;\n}\n\nconst Root = Presence;\n\nexport {\n  Presence,\n  //\n  Root,\n};\nexport type { PresenceProps };\n","import * as React from 'react';\n\ntype Machine<S> = { [k: string]: { [k: string]: S } };\ntype MachineState<T> = keyof T;\ntype MachineEvent<T> = keyof UnionToIntersection<T[keyof T]>;\n\n// 🤯 https://fettblog.eu/typescript-union-to-intersection/\ntype UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any\n  ? R\n  : never;\n\nexport function useStateMachine<M>(\n  initialState: MachineState<M>,\n  machine: M & Machine<MachineState<M>>\n) {\n  return React.useReducer((state: MachineState<M>, event: MachineEvent<M>): MachineState<M> => {\n    const nextState = (machine[state] as any)[event];\n    return nextState ?? state;\n  }, initialState);\n}\n","export * from '../client/components/navigation';\n\n//# sourceMappingURL=navigation.js.map","// extracted by mini-css-extract-plugin\nmodule.exports = {\"style\":{\"fontFamily\":\"'geistMono', 'geistMono Fallback'\"},\"className\":\"__className_c3aa02\",\"variable\":\"__variable_c3aa02\"};"],"names":["node","duration","event","Root","ReactQueryDevtools"],"sourceRoot":"","ignoreList":[2,3,4,5,6,10,11]}